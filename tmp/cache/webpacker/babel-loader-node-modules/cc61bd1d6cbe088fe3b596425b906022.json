{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nimport { __spreadArrays, __assign, __extends, __rest } from 'tslib';\nimport { $$asyncIterator, isAsyncIterable } from 'iterall';\nimport { toPromise, execute, Observable, ApolloLink, concat } from 'apollo-link';\nimport { isCompositeType, doTypesOverlap, visit, visitWithTypeInfo, Kind, getNamedType, TypeInfo, isAbstractType, isObjectType, isInterfaceType, TypeNameMetaFieldDef, GraphQLError, getDirectiveValues, GraphQLSkipDirective, GraphQLIncludeDirective, typeFromAST as typeFromAST$1, responsePathAsArray, getNullableType, isLeafType, isListType, isInputObjectType, isNonNullType, versionInfo, getOperationRootType, lexicographicSortSchema, printError, isSchema, isDirective, isNamedType, isUnionType, isEnumType, isScalarType, GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID, GraphQLSchema, GraphQLDirective, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLInputObjectType, GraphQLEnumType, GraphQLScalarType, GraphQLList, GraphQLNonNull, isInputType, buildASTSchema, parse, extendSchema as extendSchema$1, valueFromAST, print, validate, execute as execute$1, subscribe, defaultFieldResolver, graphql, buildClientSchema, getIntrospectionQuery, DirectiveLocation, TokenKind, BREAK } from 'graphql';\nimport { deprecated } from 'deprecated-decorator';\nimport { createUploadLink, isExtractableFile as _isExtractableFile, formDataAppendFile as _formDataAppendFile } from 'apollo-upload-client';\nimport FormData from 'form-data';\nimport fetch from 'node-fetch';\nimport { v4 } from 'uuid';\n\nfunction isSubschemaConfig(value) {\n  return Boolean(value.schema);\n}\n\nvar VisitSchemaKind;\n\n(function (VisitSchemaKind) {\n  VisitSchemaKind[\"TYPE\"] = \"VisitSchemaKind.TYPE\";\n  VisitSchemaKind[\"SCALAR_TYPE\"] = \"VisitSchemaKind.SCALAR_TYPE\";\n  VisitSchemaKind[\"ENUM_TYPE\"] = \"VisitSchemaKind.ENUM_TYPE\";\n  VisitSchemaKind[\"COMPOSITE_TYPE\"] = \"VisitSchemaKind.COMPOSITE_TYPE\";\n  VisitSchemaKind[\"OBJECT_TYPE\"] = \"VisitSchemaKind.OBJECT_TYPE\";\n  VisitSchemaKind[\"INPUT_OBJECT_TYPE\"] = \"VisitSchemaKind.INPUT_OBJECT_TYPE\";\n  VisitSchemaKind[\"ABSTRACT_TYPE\"] = \"VisitSchemaKind.ABSTRACT_TYPE\";\n  VisitSchemaKind[\"UNION_TYPE\"] = \"VisitSchemaKind.UNION_TYPE\";\n  VisitSchemaKind[\"INTERFACE_TYPE\"] = \"VisitSchemaKind.INTERFACE_TYPE\";\n  VisitSchemaKind[\"ROOT_OBJECT\"] = \"VisitSchemaKind.ROOT_OBJECT\";\n  VisitSchemaKind[\"QUERY\"] = \"VisitSchemaKind.QUERY\";\n  VisitSchemaKind[\"MUTATION\"] = \"VisitSchemaKind.MUTATION\";\n  VisitSchemaKind[\"SUBSCRIPTION\"] = \"VisitSchemaKind.SUBSCRIPTION\";\n})(VisitSchemaKind || (VisitSchemaKind = {}));\n\nvar MapperKind;\n\n(function (MapperKind) {\n  MapperKind[\"TYPE\"] = \"MapperKind.TYPE\";\n  MapperKind[\"SCALAR_TYPE\"] = \"MapperKind.SCALAR_TYPE\";\n  MapperKind[\"ENUM_TYPE\"] = \"MapperKind.ENUM_TYPE\";\n  MapperKind[\"COMPOSITE_TYPE\"] = \"MapperKind.COMPOSITE_TYPE\";\n  MapperKind[\"OBJECT_TYPE\"] = \"MapperKind.OBJECT_TYPE\";\n  MapperKind[\"INPUT_OBJECT_TYPE\"] = \"MapperKind.INPUT_OBJECT_TYPE\";\n  MapperKind[\"ABSTRACT_TYPE\"] = \"MapperKind.ABSTRACT_TYPE\";\n  MapperKind[\"UNION_TYPE\"] = \"MapperKind.UNION_TYPE\";\n  MapperKind[\"INTERFACE_TYPE\"] = \"MapperKind.INTERFACE_TYPE\";\n  MapperKind[\"ROOT_OBJECT\"] = \"MapperKind.ROOT_OBJECT\";\n  MapperKind[\"QUERY\"] = \"MapperKind.QUERY\";\n  MapperKind[\"MUTATION\"] = \"MapperKind.MUTATION\";\n  MapperKind[\"SUBSCRIPTION\"] = \"MapperKind.SUBSCRIPTION\";\n  MapperKind[\"DIRECTIVE\"] = \"MapperKind.DIRECTIVE\";\n})(MapperKind || (MapperKind = {}));\n\nfunction implementsAbstractType(schema, typeA, typeB) {\n  if (typeA === typeB) {\n    return true;\n  } else if (isCompositeType(typeA) && isCompositeType(typeB)) {\n    return doTypesOverlap(schema, typeA, typeB);\n  }\n\n  return false;\n}\n\nvar ExpandAbstractTypes =\n/** @class */\nfunction () {\n  function ExpandAbstractTypes(sourceSchema, targetSchema) {\n    this.targetSchema = targetSchema;\n    this.mapping = extractPossibleTypes(sourceSchema, targetSchema);\n    this.reverseMapping = flipMapping(this.mapping);\n  }\n\n  ExpandAbstractTypes.prototype.transformRequest = function (originalRequest) {\n    var document = expandAbstractTypes(this.targetSchema, this.mapping, this.reverseMapping, originalRequest.document);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return ExpandAbstractTypes;\n}();\n\nfunction extractPossibleTypes(sourceSchema, targetSchema) {\n  var typeMap = sourceSchema.getTypeMap();\n  var mapping = Object.create(null);\n  Object.keys(typeMap).forEach(function (typeName) {\n    var type = typeMap[typeName];\n\n    if (isAbstractType(type)) {\n      var targetType = targetSchema.getType(typeName);\n\n      if (!isAbstractType(targetType)) {\n        var implementations = sourceSchema.getPossibleTypes(type);\n        mapping[typeName] = implementations.filter(function (impl) {\n          return targetSchema.getType(impl.name);\n        }).map(function (impl) {\n          return impl.name;\n        });\n      }\n    }\n  });\n  return mapping;\n}\n\nfunction flipMapping(mapping) {\n  var result = Object.create(null);\n  Object.keys(mapping).forEach(function (typeName) {\n    var toTypeNames = mapping[typeName];\n    toTypeNames.forEach(function (toTypeName) {\n      if (!(toTypeName in result)) {\n        result[toTypeName] = [];\n      }\n\n      result[toTypeName].push(typeName);\n    });\n  });\n  return result;\n}\n\nfunction expandAbstractTypes(targetSchema, mapping, reverseMapping, document) {\n  var _a;\n\n  var operations = document.definitions.filter(function (def) {\n    return def.kind === Kind.OPERATION_DEFINITION;\n  });\n  var fragments = document.definitions.filter(function (def) {\n    return def.kind === Kind.FRAGMENT_DEFINITION;\n  });\n  var existingFragmentNames = fragments.map(function (fragment) {\n    return fragment.name.value;\n  });\n  var fragmentCounter = 0;\n\n  var generateFragmentName = function generateFragmentName(typeName) {\n    var fragmentName;\n\n    do {\n      fragmentName = \"_\" + typeName + \"_Fragment\" + fragmentCounter.toString();\n      fragmentCounter++;\n    } while (existingFragmentNames.indexOf(fragmentName) !== -1);\n\n    return fragmentName;\n  };\n\n  var newFragments = [];\n  var fragmentReplacements = Object.create(null);\n  fragments.forEach(function (fragment) {\n    newFragments.push(fragment);\n    var possibleTypes = mapping[fragment.typeCondition.name.value];\n\n    if (possibleTypes != null) {\n      fragmentReplacements[fragment.name.value] = [];\n      possibleTypes.forEach(function (possibleTypeName) {\n        var name = generateFragmentName(possibleTypeName);\n        existingFragmentNames.push(name);\n        var newFragment = {\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name\n          },\n          typeCondition: {\n            kind: Kind.NAMED_TYPE,\n            name: {\n              kind: Kind.NAME,\n              value: possibleTypeName\n            }\n          },\n          selectionSet: fragment.selectionSet\n        };\n        newFragments.push(newFragment);\n        fragmentReplacements[fragment.name.value].push({\n          fragmentName: name,\n          typeName: possibleTypeName\n        });\n      });\n    }\n  });\n\n  var newDocument = __assign(__assign({}, document), {\n    definitions: __spreadArrays(operations, newFragments)\n  });\n\n  var typeInfo = new TypeInfo(targetSchema);\n  return visit(newDocument, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n    var newSelections = __spreadArrays(node.selections);\n\n    var maybeType = typeInfo.getParentType();\n\n    if (maybeType != null) {\n      var parentType_1 = getNamedType(maybeType);\n      node.selections.forEach(function (selection) {\n        if (selection.kind === Kind.INLINE_FRAGMENT) {\n          if (selection.typeCondition != null) {\n            var possibleTypes = mapping[selection.typeCondition.name.value];\n\n            if (possibleTypes != null) {\n              possibleTypes.forEach(function (possibleType) {\n                var maybePossibleType = targetSchema.getType(possibleType);\n\n                if (maybePossibleType != null && implementsAbstractType(targetSchema, parentType_1, maybePossibleType)) {\n                  newSelections.push({\n                    kind: Kind.INLINE_FRAGMENT,\n                    typeCondition: {\n                      kind: Kind.NAMED_TYPE,\n                      name: {\n                        kind: Kind.NAME,\n                        value: possibleType\n                      }\n                    },\n                    selectionSet: selection.selectionSet\n                  });\n                }\n              });\n            }\n          }\n        } else if (selection.kind === Kind.FRAGMENT_SPREAD) {\n          var fragmentName = selection.name.value;\n\n          if (fragmentName in fragmentReplacements) {\n            fragmentReplacements[fragmentName].forEach(function (replacement) {\n              var typeName = replacement.typeName;\n              var maybeReplacementType = targetSchema.getType(typeName);\n\n              if (maybeReplacementType != null && implementsAbstractType(targetSchema, parentType_1, maybeType)) {\n                newSelections.push({\n                  kind: Kind.FRAGMENT_SPREAD,\n                  name: {\n                    kind: Kind.NAME,\n                    value: replacement.fragmentName\n                  }\n                });\n              }\n            });\n          }\n        }\n      });\n\n      if (parentType_1.name in reverseMapping) {\n        newSelections.push({\n          kind: Kind.FIELD,\n          name: {\n            kind: Kind.NAME,\n            value: '__typename'\n          }\n        });\n      }\n    }\n\n    if (newSelections.length !== node.selections.length) {\n      return __assign(__assign({}, node), {\n        selections: newSelections\n      });\n    }\n  }, _a)));\n}\n/**\r\n * Creates a keyed JS object from an array, given a function to produce the keys\r\n * and a function to produce the values from each item in the array.\r\n *\r\n *     const phoneBook = [\r\n *       { name: 'Jon', num: '555-1234' },\r\n *       { name: 'Jenny', num: '867-5309' }\r\n *     ]\r\n *\r\n *     // { Jon: '555-1234', Jenny: '867-5309' }\r\n *     const phonesByName = keyValMap(\r\n *       phoneBook,\r\n *       entry => entry.name,\r\n *       entry => entry.num\r\n *     )\r\n *\r\n */\n\n\nfunction keyValMap(list, keyFn, valFn) {\n  return list.reduce(function (map, item) {\n    map[keyFn(item)] = valFn(item);\n    return map;\n  }, Object.create(null));\n}\n\nvar FilterToSchema =\n/** @class */\nfunction () {\n  function FilterToSchema(targetSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  FilterToSchema.prototype.transformRequest = function (originalRequest) {\n    return __assign(__assign({}, originalRequest), filterToSchema(this.targetSchema, originalRequest.document, originalRequest.variables));\n  };\n\n  return FilterToSchema;\n}();\n\nfunction filterToSchema(targetSchema, document, variables) {\n  var operations = document.definitions.filter(function (def) {\n    return def.kind === Kind.OPERATION_DEFINITION;\n  });\n  var fragments = document.definitions.filter(function (def) {\n    return def.kind === Kind.FRAGMENT_DEFINITION;\n  });\n  var usedVariables = [];\n  var usedFragments = [];\n  var newOperations = [];\n  var newFragments = [];\n  var validFragments = fragments.filter(function (fragment) {\n    var typeName = fragment.typeCondition.name.value;\n    return Boolean(targetSchema.getType(typeName));\n  });\n  var validFragmentsWithType = keyValMap(validFragments, function (fragment) {\n    return fragment.name.value;\n  }, function (fragment) {\n    return targetSchema.getType(fragment.typeCondition.name.value);\n  });\n  var fragmentSet = Object.create(null);\n  operations.forEach(function (operation) {\n    var type;\n\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n\n    var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, operation.selectionSet),\n        selectionSet = _a.selectionSet,\n        operationUsedFragments = _a.usedFragments,\n        operationUsedVariables = _a.usedVariables;\n\n    usedFragments = union(usedFragments, operationUsedFragments);\n\n    var _b = collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments),\n        collectedUsedVariables = _b.usedVariables,\n        collectedNewFragments = _b.newFragments,\n        collectedFragmentSet = _b.fragmentSet;\n\n    var operationOrFragmentVariables = union(operationUsedVariables, collectedUsedVariables);\n    usedVariables = union(usedVariables, operationOrFragmentVariables);\n    newFragments = collectedNewFragments;\n    fragmentSet = collectedFragmentSet;\n    var variableDefinitions = operation.variableDefinitions.filter(function (variable) {\n      return operationOrFragmentVariables.indexOf(variable.variable.name.value) !== -1;\n    });\n    newOperations.push({\n      kind: Kind.OPERATION_DEFINITION,\n      operation: operation.operation,\n      name: operation.name,\n      directives: operation.directives,\n      variableDefinitions: variableDefinitions,\n      selectionSet: selectionSet\n    });\n  });\n  var newVariables = usedVariables.reduce(function (acc, variableName) {\n    acc[variableName] = variables[variableName];\n    return acc;\n  }, {});\n  return {\n    document: {\n      kind: Kind.DOCUMENT,\n      definitions: __spreadArrays(newOperations, newFragments)\n    },\n    variables: newVariables\n  };\n}\n\nfunction collectFragmentVariables(targetSchema, fragmentSet, validFragments, validFragmentsWithType, usedFragments) {\n  var remainingFragments = usedFragments.slice();\n  var usedVariables = [];\n  var newFragments = [];\n\n  var _loop_1 = function _loop_1() {\n    var nextFragmentName = remainingFragments.pop();\n    var fragment = validFragments.find(function (fr) {\n      return fr.name.value === nextFragmentName;\n    });\n\n    if (fragment != null) {\n      var name_1 = nextFragmentName;\n      var typeName = fragment.typeCondition.name.value;\n      var type = targetSchema.getType(typeName);\n\n      var _a = filterSelectionSet(targetSchema, type, validFragmentsWithType, fragment.selectionSet),\n          selectionSet = _a.selectionSet,\n          fragmentUsedFragments = _a.usedFragments,\n          fragmentUsedVariables = _a.usedVariables;\n\n      remainingFragments = union(remainingFragments, fragmentUsedFragments);\n      usedVariables = union(usedVariables, fragmentUsedVariables);\n\n      if (!(name_1 in fragmentSet)) {\n        fragmentSet[name_1] = true;\n        newFragments.push({\n          kind: Kind.FRAGMENT_DEFINITION,\n          name: {\n            kind: Kind.NAME,\n            value: name_1\n          },\n          typeCondition: fragment.typeCondition,\n          selectionSet: selectionSet\n        });\n      }\n    }\n  };\n\n  while (remainingFragments.length !== 0) {\n    _loop_1();\n  }\n\n  return {\n    usedVariables: usedVariables,\n    newFragments: newFragments,\n    fragmentSet: fragmentSet\n  };\n}\n\nfunction filterSelectionSet(schema, type, validFragments, selectionSet) {\n  var _a;\n\n  var usedFragments = [];\n  var usedVariables = [];\n  var typeInfo = new TypeInfo(schema, undefined, type);\n  var filteredSelectionSet = visit(selectionSet, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.FIELD] = {\n    enter: function enter(node) {\n      var parentType = typeInfo.getParentType();\n\n      if (isObjectType(parentType) || isInterfaceType(parentType)) {\n        var fields = parentType.getFields();\n        var field = node.name.value === '__typename' ? TypeNameMetaFieldDef : fields[node.name.value];\n\n        if (!field) {\n          return null;\n        }\n\n        var argNames_1 = (field.args != null ? field.args : []).map(function (arg) {\n          return arg.name;\n        });\n\n        if (node.arguments != null) {\n          var args = node.arguments.filter(function (arg) {\n            return argNames_1.indexOf(arg.name.value) !== -1;\n          });\n\n          if (args.length !== node.arguments.length) {\n            return __assign(__assign({}, node), {\n              arguments: args\n            });\n          }\n        }\n      }\n    },\n    leave: function leave(node) {\n      var _a;\n\n      var resolvedType = getNamedType(typeInfo.getType());\n\n      if (isObjectType(resolvedType) || isInterfaceType(resolvedType)) {\n        var selections = node.selectionSet != null ? node.selectionSet.selections : null;\n\n        if (selections == null || selections.length === 0) {\n          // need to remove any added variables. Is there a better way to do this?\n          visit(node, (_a = {}, _a[Kind.VARIABLE] = function (variableNode) {\n            var index = usedVariables.indexOf(variableNode.name.value);\n\n            if (index !== -1) {\n              usedVariables.splice(index, 1);\n            }\n          }, _a));\n          return null;\n        }\n      }\n    }\n  }, _a[Kind.FRAGMENT_SPREAD] = function (node) {\n    if (node.name.value in validFragments) {\n      var parentType = typeInfo.getParentType();\n      var innerType = validFragments[node.name.value];\n\n      if (!implementsAbstractType(schema, parentType, innerType)) {\n        return null;\n      }\n\n      usedFragments.push(node.name.value);\n      return;\n    }\n\n    return null;\n  }, _a[Kind.INLINE_FRAGMENT] = {\n    enter: function enter(node) {\n      if (node.typeCondition != null) {\n        var parentType = typeInfo.getParentType();\n        var innerType = schema.getType(node.typeCondition.name.value);\n\n        if (!implementsAbstractType(schema, parentType, innerType)) {\n          return null;\n        }\n      }\n    }\n  }, _a[Kind.VARIABLE] = function (node) {\n    usedVariables.push(node.name.value);\n  }, _a)));\n  return {\n    selectionSet: filteredSelectionSet,\n    usedFragments: usedFragments,\n    usedVariables: usedVariables\n  };\n}\n\nfunction union() {\n  var arrays = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    arrays[_i] = arguments[_i];\n  }\n\n  var cache = Object.create(null);\n  var result = [];\n  arrays.forEach(function (array) {\n    array.forEach(function (item) {\n      if (!(item in cache)) {\n        cache[item] = true;\n        result.push(item);\n      }\n    });\n  });\n  return result;\n}\n\nvar AddReplacementSelectionSets =\n/** @class */\nfunction () {\n  function AddReplacementSelectionSets(schema, mapping) {\n    this.schema = schema;\n    this.mapping = mapping;\n  }\n\n  AddReplacementSelectionSets.prototype.transformRequest = function (originalRequest) {\n    var document = replaceFieldsWithSelectionSet(this.schema, originalRequest.document, this.mapping);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return AddReplacementSelectionSets;\n}();\n\nfunction replaceFieldsWithSelectionSet(schema, document, mapping) {\n  var _a;\n\n  var typeInfo = new TypeInfo(schema);\n  return visit(document, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n\n    if (parentType != null) {\n      var parentTypeName_1 = parentType.name;\n      var selections_1 = node.selections;\n\n      if (parentTypeName_1 in mapping) {\n        node.selections.forEach(function (selection) {\n          if (selection.kind === Kind.FIELD) {\n            var name_1 = selection.name.value;\n            var selectionSet = mapping[parentTypeName_1][name_1];\n\n            if (selectionSet != null) {\n              selections_1 = selections_1.concat(selectionSet.selections);\n            }\n          }\n        });\n      }\n\n      if (selections_1 !== node.selections) {\n        return __assign(__assign({}, node), {\n          selections: selections_1\n        });\n      }\n    }\n  }, _a)));\n}\n\nvar AddReplacementFragments =\n/** @class */\nfunction () {\n  function AddReplacementFragments(targetSchema, mapping) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  AddReplacementFragments.prototype.transformRequest = function (originalRequest) {\n    var document = replaceFieldsWithFragments(this.targetSchema, originalRequest.document, this.mapping);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return AddReplacementFragments;\n}();\n\nfunction replaceFieldsWithFragments(targetSchema, document, mapping) {\n  var _a;\n\n  var typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n\n    if (parentType != null) {\n      var parentTypeName_1 = parentType.name;\n      var selections_1 = node.selections;\n\n      if (parentTypeName_1 in mapping) {\n        node.selections.forEach(function (selection) {\n          if (selection.kind === Kind.FIELD) {\n            var name_1 = selection.name.value;\n            var fragment = mapping[parentTypeName_1][name_1];\n\n            if (fragment != null) {\n              selections_1 = selections_1.concat(fragment);\n            }\n          }\n        });\n      }\n\n      if (selections_1 !== node.selections) {\n        return __assign(__assign({}, node), {\n          selections: selections_1\n        });\n      }\n    }\n  }, _a)));\n}\n\nvar AddMergedTypeFragments =\n/** @class */\nfunction () {\n  function AddMergedTypeFragments(targetSchema, mapping) {\n    this.targetSchema = targetSchema;\n    this.mapping = mapping;\n  }\n\n  AddMergedTypeFragments.prototype.transformRequest = function (originalRequest) {\n    var document = addMergedTypeSelectionSets(this.targetSchema, originalRequest.document, this.mapping);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return AddMergedTypeFragments;\n}();\n\nfunction addMergedTypeSelectionSets(targetSchema, document, mapping) {\n  var _a;\n\n  var typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n\n    if (parentType != null) {\n      var parentTypeName = parentType.name;\n      var selections = node.selections;\n\n      if (parentTypeName in mapping) {\n        var selectionSet = mapping[parentTypeName].selectionSet;\n\n        if (selectionSet != null) {\n          selections = selections.concat(selectionSet.selections);\n        }\n      }\n\n      if (selections !== node.selections) {\n        return __assign(__assign({}, node), {\n          selections: selections\n        });\n      }\n    }\n  }, _a)));\n}\n\nfunction addTypenameToAbstract(targetSchema, document) {\n  var _a;\n\n  var typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n    var selections = node.selections;\n\n    if (parentType != null && isAbstractType(parentType)) {\n      selections = selections.concat({\n        kind: Kind.FIELD,\n        name: {\n          kind: Kind.NAME,\n          value: '__typename'\n        }\n      });\n    }\n\n    if (selections !== node.selections) {\n      return __assign(__assign({}, node), {\n        selections: selections\n      });\n    }\n  }, _a)));\n}\n\nvar AddTypenameToAbstract =\n/** @class */\nfunction () {\n  function AddTypenameToAbstract(targetSchema) {\n    this.targetSchema = targetSchema;\n  }\n\n  AddTypenameToAbstract.prototype.transformRequest = function (originalRequest) {\n    var document = addTypenameToAbstract(this.targetSchema, originalRequest.document);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return AddTypenameToAbstract;\n}();\n/**\r\n * Get the key under which the result of this resolver will be placed in the response JSON. Basically, just\r\n * resolves aliases.\r\n * @param info The info argument to the resolver.\r\n */\n\n\nfunction getResponseKeyFromInfo(info) {\n  return info.fieldNodes[0].alias != null ? info.fieldNodes[0].alias.value : info.fieldName;\n}\n\nvar hasSymbol = typeof global !== 'undefined' && 'Symbol' in global || // eslint-disable-next-line no-undef\ntypeof window !== 'undefined' && 'Symbol' in window;\nvar OBJECT_SUBSCHEMA_SYMBOL = hasSymbol ? Symbol('initialSubschema') : '@@__initialSubschema';\nvar FIELD_SUBSCHEMA_MAP_SYMBOL = hasSymbol ? Symbol('subschemaMap') : '@@__subschemaMap';\nvar ERROR_SYMBOL = hasSymbol ? Symbol('subschemaErrors') : '@@__subschemaErrors';\n\nfunction relocatedError(originalError, nodes, path) {\n  if (Array.isArray(originalError.path)) {\n    return new GraphQLError(originalError.message, originalError.nodes, originalError.source, originalError.positions, path != null ? path : originalError.path, originalError.originalError, originalError.extensions);\n  }\n\n  if (originalError == null) {\n    return new GraphQLError(undefined, nodes, undefined, undefined, path, originalError);\n  }\n\n  return new GraphQLError(originalError.message, originalError.nodes != null ? originalError.nodes : nodes, originalError.source, originalError.positions, path, originalError);\n}\n\nfunction slicedError(originalError) {\n  return relocatedError(originalError, originalError.nodes, originalError.path != null ? originalError.path.slice(1) : undefined);\n}\n\nfunction getErrorsByPathSegment(errors) {\n  var record = Object.create(null);\n  errors.forEach(function (error) {\n    if (!error.path || error.path.length < 2) {\n      return;\n    }\n\n    var pathSegment = error.path[1];\n    var current = pathSegment in record ? record[pathSegment] : [];\n    current.push(slicedError(error));\n    record[pathSegment] = current;\n  });\n  return record;\n}\n\nvar CombinedError =\n/** @class */\nfunction (_super) {\n  __extends(CombinedError, _super);\n\n  function CombinedError(message, errors) {\n    var _this = _super.call(this, message) || this;\n\n    _this.errors = errors;\n    return _this;\n  }\n\n  return CombinedError;\n}(Error);\n\nfunction combineErrors(errors) {\n  if (errors.length === 1) {\n    return new GraphQLError(errors[0].message, errors[0].nodes, errors[0].source, errors[0].positions, errors[0].path, errors[0].originalError, errors[0].extensions);\n  }\n\n  return new CombinedError(errors.map(function (error) {\n    return error.message;\n  }).join('\\n'), errors);\n}\n\nfunction setErrors(result, errors) {\n  result[ERROR_SYMBOL] = errors;\n}\n\nfunction getErrors(result, pathSegment) {\n  var errors = result != null ? result[ERROR_SYMBOL] : result;\n\n  if (!Array.isArray(errors)) {\n    return null;\n  }\n\n  var fieldErrors = [];\n\n  for (var _i = 0, errors_1 = errors; _i < errors_1.length; _i++) {\n    var error = errors_1[_i];\n\n    if (!error.path || error.path[0] === pathSegment) {\n      fieldErrors.push(error);\n    }\n  }\n\n  return fieldErrors;\n}\n\nfunction handleNull(fieldNodes, path, errors) {\n  if (errors.length) {\n    if (errors.some(function (error) {\n      return !error.path || error.path.length < 2;\n    })) {\n      return relocatedError(combineErrors(errors), fieldNodes, path);\n    } else if (errors.some(function (error) {\n      return typeof error.path[1] === 'string';\n    })) {\n      var childErrors_1 = getErrorsByPathSegment(errors);\n      var result_1 = {};\n      Object.keys(childErrors_1).forEach(function (pathSegment) {\n        result_1[pathSegment] = handleNull(fieldNodes, __spreadArrays(path, [pathSegment]), childErrors_1[pathSegment]);\n      });\n      return result_1;\n    }\n\n    var childErrors_2 = getErrorsByPathSegment(errors);\n    var result_2 = [];\n    Object.keys(childErrors_2).forEach(function (pathSegment) {\n      result_2.push(handleNull(fieldNodes, __spreadArrays(path, [parseInt(pathSegment, 10)]), childErrors_2[pathSegment]));\n    });\n    return result_2;\n  }\n\n  return null;\n}\n/**\r\n * Given a selectionSet, adds all of the fields in that selection to\r\n * the passed in map of fields, and returns it at the end.\r\n *\r\n * CollectFields requires the \"runtime type\" of an object. For a field which\r\n * returns an Interface or Union type, the \"runtime type\" will be the actual\r\n * Object type returned by that field.\r\n *\r\n * @internal\r\n */\n\n\nfunction collectFields(exeContext, runtimeType, selectionSet, fields, visitedFragmentNames) {\n  for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n    var selection = _a[_i];\n\n    switch (selection.kind) {\n      case Kind.FIELD:\n        {\n          if (!shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          var name_1 = getFieldEntryKey(selection);\n\n          if (!(name_1 in fields)) {\n            fields[name_1] = [];\n          }\n\n          fields[name_1].push(selection);\n          break;\n        }\n\n      case Kind.INLINE_FRAGMENT:\n        {\n          if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {\n            continue;\n          }\n\n          collectFields(exeContext, runtimeType, selection.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n\n      case Kind.FRAGMENT_SPREAD:\n        {\n          var fragName = selection.name.value;\n\n          if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {\n            continue;\n          }\n\n          visitedFragmentNames[fragName] = true;\n          var fragment = exeContext.fragments[fragName];\n\n          if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {\n            continue;\n          }\n\n          collectFields(exeContext, runtimeType, fragment.selectionSet, fields, visitedFragmentNames);\n          break;\n        }\n    }\n  }\n\n  return fields;\n}\n/**\r\n * Determines if a field should be included based on the @include and @skip\r\n * directives, where @skip has higher precedence than @include.\r\n */\n\n\nfunction shouldIncludeNode(exeContext, node) {\n  var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);\n\n  if ((skip === null || skip === void 0 ? void 0 : skip[\"if\"]) === true) {\n    return false;\n  }\n\n  var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);\n\n  if ((include === null || include === void 0 ? void 0 : include[\"if\"]) === false) {\n    return false;\n  }\n\n  return true;\n}\n/**\r\n * Determines if a fragment is applicable to the given type.\r\n */\n\n\nfunction doesFragmentConditionMatch(exeContext, fragment, type) {\n  var typeConditionNode = fragment.typeCondition;\n\n  if (!typeConditionNode) {\n    return true;\n  }\n\n  var conditionalType = typeFromAST$1(exeContext.schema, typeConditionNode);\n\n  if (conditionalType === type) {\n    return true;\n  }\n\n  if (isAbstractType(conditionalType)) {\n    return exeContext.schema.isPossibleType(conditionalType, type);\n  }\n\n  return false;\n}\n/**\r\n * Implements the logic to compute the key of a given field's entry\r\n */\n\n\nfunction getFieldEntryKey(node) {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return node.alias ? node.alias.value : node.name.value;\n}\n\nfunction getSubschema(result, responseKey) {\n  var subschema = result[FIELD_SUBSCHEMA_MAP_SYMBOL] && result[FIELD_SUBSCHEMA_MAP_SYMBOL][responseKey];\n  return subschema ? subschema : result[OBJECT_SUBSCHEMA_SYMBOL];\n}\n\nfunction setObjectSubschema(result, subschema) {\n  result[OBJECT_SUBSCHEMA_SYMBOL] = subschema;\n}\n\nfunction resolveFromParentTypename(parent) {\n  var parentTypename = parent['__typename'];\n\n  if (!parentTypename) {\n    throw new Error('Did not fetch typename for object, unable to resolve interface.');\n  }\n\n  return parentTypename;\n}\n\nfunction mergeDeep(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  var output = __assign({}, target);\n\n  sources.forEach(function (source) {\n    if (isObject(target) && isObject(source)) {\n      Object.keys(source).forEach(function (key) {\n        var _a, _b;\n\n        if (isObject(source[key])) {\n          if (!(key in target)) {\n            Object.assign(output, (_a = {}, _a[key] = source[key], _a));\n          } else {\n            output[key] = mergeDeep(target[key], source[key]);\n          }\n        } else {\n          Object.assign(output, (_b = {}, _b[key] = source[key], _b));\n        }\n      });\n    }\n  });\n  return output;\n}\n\nfunction isObject(item) {\n  return item && _typeof(item) === 'object' && !Array.isArray(item);\n}\n\nfunction unwrapResult(parent, info, path) {\n  var newParent = parent;\n  var pathLength = path.length;\n\n  for (var i = 0; i < pathLength; i++) {\n    var responseKey = path[i];\n    var errors = getErrors(newParent, responseKey);\n    var subschema = getSubschema(newParent, responseKey);\n    var object = newParent[responseKey];\n\n    if (object == null) {\n      return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\n    }\n\n    setErrors(object, errors.map(function (error) {\n      return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);\n    }));\n    setObjectSubschema(object, subschema);\n    newParent = object;\n  }\n\n  return newParent;\n}\n\nfunction dehoistResult(parent, delimeter) {\n  if (delimeter === void 0) {\n    delimeter = '__gqltf__';\n  }\n\n  var result = Object.create(null);\n  Object.keys(parent).forEach(function (alias) {\n    var obj = result;\n    var fieldNames = alias.split(delimeter);\n    var fieldName = fieldNames.pop();\n    fieldNames.forEach(function (key) {\n      obj = obj[key] = obj[key] || Object.create(null);\n    });\n    obj[fieldName] = parent[alias];\n  });\n  result[ERROR_SYMBOL] = parent[ERROR_SYMBOL].map(function (error) {\n    if (error.path != null) {\n      var path = error.path.slice();\n      var pathSegment = path.shift();\n      var expandedPathSegment = pathSegment.split(delimeter);\n      return relocatedError(error, error.nodes, expandedPathSegment.concat(path));\n    }\n\n    return error;\n  });\n  result[OBJECT_SUBSCHEMA_SYMBOL] = parent[OBJECT_SUBSCHEMA_SYMBOL];\n  return result;\n}\n\nfunction mergeProxiedResults(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  var errors = target[ERROR_SYMBOL].concat(sources.map(function (source) {\n    return source[ERROR_SYMBOL];\n  }));\n  var fieldSubschemaMap = sources.reduce(function (acc, source) {\n    var subschema = source[OBJECT_SUBSCHEMA_SYMBOL];\n    Object.keys(source).forEach(function (key) {\n      acc[key] = subschema;\n    });\n    return acc;\n  }, {});\n  var result = mergeDeep.apply(void 0, __spreadArrays([target], sources));\n  result[ERROR_SYMBOL] = errors;\n  result[FIELD_SUBSCHEMA_MAP_SYMBOL] = target[FIELD_SUBSCHEMA_MAP_SYMBOL] ? mergeDeep(target[FIELD_SUBSCHEMA_MAP_SYMBOL], fieldSubschemaMap) : fieldSubschemaMap;\n  return result;\n}\n\nfunction buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas) {\n  // 1.  calculate if possible to delegate to given subschema\n  //    TODO: change logic so that required selection set can be spread across multiple subschemas?\n  var proxiableSubschemas = [];\n  var nonProxiableSubschemas = [];\n  targetSubschemas.forEach(function (t) {\n    if (sourceSubschemas.some(function (s) {\n      var selectionSet = mergedTypeInfo.selectionSets.get(t);\n      return mergedTypeInfo.containsSelectionSet.get(s).get(selectionSet);\n    })) {\n      proxiableSubschemas.push(t);\n    } else {\n      nonProxiableSubschemas.push(t);\n    }\n  });\n  var uniqueFields = mergedTypeInfo.uniqueFields,\n      nonUniqueFields = mergedTypeInfo.nonUniqueFields;\n  var unproxiableSelections = []; // 2. for each selection:\n\n  var delegationMap = new Map();\n  originalSelections.forEach(function (selection) {\n    // 2a. use uniqueFields map to assign fields to subschema if one of possible subschemas\n    var uniqueSubschema = uniqueFields[selection.name.value];\n\n    if (uniqueSubschema != null) {\n      if (proxiableSubschemas.includes(uniqueSubschema)) {\n        var existingSubschema = delegationMap.get(uniqueSubschema);\n\n        if (existingSubschema != null) {\n          existingSubschema.push(selection);\n        } else {\n          delegationMap.set(uniqueSubschema, [selection]);\n        }\n      } else {\n        unproxiableSelections.push(selection);\n      }\n    } else {\n      // 2b. use nonUniqueFields to assign to a possible subschema,\n      //     preferring one of the subschemas already targets of delegation\n      var nonUniqueSubschemas = nonUniqueFields[selection.name.value];\n      nonUniqueSubschemas = nonUniqueSubschemas.filter(function (s) {\n        return proxiableSubschemas.includes(s);\n      });\n\n      if (nonUniqueSubschemas != null) {\n        var subschemas_1 = Array.from(delegationMap.keys());\n        var existingSubschema = nonUniqueSubschemas.find(function (s) {\n          return subschemas_1.includes(s);\n        });\n\n        if (existingSubschema != null) {\n          delegationMap.get(existingSubschema).push(selection);\n        } else {\n          delegationMap.set(nonUniqueSubschemas[0], [selection]);\n        }\n      } else {\n        unproxiableSelections.push(selection);\n      }\n    }\n  });\n  return {\n    delegationMap: delegationMap,\n    unproxiableSelections: unproxiableSelections,\n    proxiableSubschemas: proxiableSubschemas,\n    nonProxiableSubschemas: nonProxiableSubschemas\n  };\n}\n\nfunction mergeFields(mergedTypeInfo, typeName, object, originalSelections, sourceSubschemas, targetSubschemas, context, info) {\n  if (!originalSelections.length) {\n    return object;\n  }\n\n  var _a = buildDelegationPlan(mergedTypeInfo, originalSelections, sourceSubschemas, targetSubschemas),\n      delegationMap = _a.delegationMap,\n      unproxiableSelections = _a.unproxiableSelections,\n      proxiableSubschemas = _a.proxiableSubschemas,\n      nonProxiableSubschemas = _a.nonProxiableSubschemas;\n\n  if (!delegationMap.size) {\n    return object;\n  }\n\n  var maybePromises = [];\n  delegationMap.forEach(function (selections, s) {\n    var maybePromise = s.merge[typeName].resolve(object, context, info, s, {\n      kind: Kind.SELECTION_SET,\n      selections: selections\n    });\n    maybePromises.push(maybePromise);\n  });\n  var containsPromises = false;\n\n  for (var _i = 0, maybePromises_1 = maybePromises; _i < maybePromises_1.length; _i++) {\n    var maybePromise = maybePromises_1[_i];\n\n    if (maybePromise instanceof Promise) {\n      containsPromises = true;\n      break;\n    }\n  }\n\n  return containsPromises ? Promise.all(maybePromises).then(function (results) {\n    return mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], results)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);\n  }) : mergeFields(mergedTypeInfo, typeName, mergeProxiedResults.apply(void 0, __spreadArrays([object], maybePromises)), unproxiableSelections, sourceSubschemas.concat(proxiableSubschemas), nonProxiableSubschemas, context, info);\n}\n\nfunction handleObject(type, object, errors, subschema, context, info, skipTypeMerging) {\n  setErrors(object, errors.map(function (error) {\n    return relocatedError(error, error.nodes, error.path != null ? error.path.slice(1) : undefined);\n  }));\n  setObjectSubschema(object, subschema);\n\n  if (skipTypeMerging || !info.mergeInfo) {\n    return object;\n  }\n\n  var typeName = isAbstractType(type) ? info.schema.getTypeMap()[resolveFromParentTypename(object)].name : type.name;\n  var mergedTypeInfo = info.mergeInfo.mergedTypes[typeName];\n  var targetSubschemas;\n\n  if (mergedTypeInfo != null) {\n    targetSubschemas = mergedTypeInfo.subschemas;\n  }\n\n  if (!targetSubschemas) {\n    return object;\n  }\n\n  targetSubschemas = targetSubschemas.filter(function (s) {\n    return s !== subschema;\n  });\n\n  if (!targetSubschemas.length) {\n    return object;\n  }\n\n  var subFields = collectSubFields(info, object.__typename);\n  var selections = getFieldsNotInSubschema(subFields, subschema, mergedTypeInfo, object.__typename);\n  return mergeFields(mergedTypeInfo, typeName, object, selections, [subschema], targetSubschemas, context, info);\n}\n\nfunction collectSubFields(info, typeName) {\n  var subFieldNodes = Object.create(null);\n  var visitedFragmentNames = Object.create(null);\n  info.fieldNodes.forEach(function (fieldNode) {\n    subFieldNodes = collectFields({\n      schema: info.schema,\n      variableValues: info.variableValues,\n      fragments: info.fragments\n    }, info.schema.getType(typeName), fieldNode.selectionSet, subFieldNodes, visitedFragmentNames);\n  });\n  return subFieldNodes;\n}\n\nfunction getFieldsNotInSubschema(subFieldNodes, subschema, mergedTypeInfo, typeName) {\n  var typeMap = isSubschemaConfig(subschema) ? mergedTypeInfo.typeMaps.get(subschema) : subschema.getTypeMap();\n  var fields = typeMap[typeName].getFields();\n  var fieldsNotInSchema = [];\n  Object.keys(subFieldNodes).forEach(function (responseName) {\n    subFieldNodes[responseName].forEach(function (subFieldNode) {\n      if (!(subFieldNode.name.value in fields)) {\n        fieldsNotInSchema.push(subFieldNode);\n      }\n    });\n  });\n  return fieldsNotInSchema;\n}\n\nfunction handleList(type, list, errors, subschema, context, info, skipTypeMerging) {\n  var childErrors = getErrorsByPathSegment(errors);\n  return list.map(function (listMember, index) {\n    return handleListMember(getNullableType(type.ofType), listMember, index, index in childErrors ? childErrors[index] : [], subschema, context, info, skipTypeMerging);\n  });\n}\n\nfunction handleListMember(type, listMember, index, errors, subschema, context, info, skipTypeMerging) {\n  if (listMember == null) {\n    return handleNull(info.fieldNodes, __spreadArrays(responsePathAsArray(info.path), [index]), errors);\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(listMember);\n  } else if (isCompositeType(type)) {\n    return handleObject(type, listMember, errors, subschema, context, info, skipTypeMerging);\n  } else if (isListType(type)) {\n    return handleList(type, listMember, errors, subschema, context, info, skipTypeMerging);\n  }\n}\n\nfunction checkResultAndHandleErrors(result, context, info, responseKey, subschema, returnType, skipTypeMerging) {\n  if (responseKey === void 0) {\n    responseKey = getResponseKeyFromInfo(info);\n  }\n\n  if (returnType === void 0) {\n    returnType = info.returnType;\n  }\n\n  var errors = result.errors != null ? result.errors : [];\n  var data = result.data != null ? result.data[responseKey] : undefined;\n  return handleResult(data, errors, subschema, context, info, returnType, skipTypeMerging);\n}\n\nfunction handleResult(result, errors, subschema, context, info, returnType, skipTypeMerging) {\n  if (returnType === void 0) {\n    returnType = info.returnType;\n  }\n\n  var type = getNullableType(returnType);\n\n  if (result == null) {\n    return handleNull(info.fieldNodes, responsePathAsArray(info.path), errors);\n  }\n\n  if (isLeafType(type)) {\n    return type.parseValue(result);\n  } else if (isCompositeType(type)) {\n    return handleObject(type, result, errors, subschema, context, info, skipTypeMerging);\n  } else if (isListType(type)) {\n    return handleList(type, result, errors, subschema, context, info, skipTypeMerging);\n  }\n}\n\nvar CheckResultAndHandleErrors =\n/** @class */\nfunction () {\n  function CheckResultAndHandleErrors(info, fieldName, subschema, context, returnType, typeMerge) {\n    if (returnType === void 0) {\n      returnType = info.returnType;\n    }\n\n    this.context = context;\n    this.info = info;\n    this.fieldName = fieldName;\n    this.subschema = subschema;\n    this.returnType = returnType;\n    this.typeMerge = typeMerge;\n  }\n\n  CheckResultAndHandleErrors.prototype.transformResult = function (result) {\n    return checkResultAndHandleErrors(result, this.context != null ? this.context : {}, this.info, this.fieldName, this.subschema, this.returnType, this.typeMerge);\n  };\n\n  return CheckResultAndHandleErrors;\n}();\n\nfunction transformInputValue(type, value, transformer) {\n  if (value == null) {\n    return value;\n  }\n\n  var nullableType = getNullableType(type);\n\n  if (isLeafType(nullableType)) {\n    return transformer(nullableType, value);\n  } else if (isListType(nullableType)) {\n    return value.map(function (listMember) {\n      return transformInputValue(nullableType.ofType, listMember, transformer);\n    });\n  } else if (isInputObjectType(nullableType)) {\n    var fields_1 = nullableType.getFields();\n    return keyValMap(Object.keys(value), function (key) {\n      return key;\n    }, function (key) {\n      return transformInputValue(fields_1[key].type, value[key], transformer);\n    });\n  } // unreachable, no other possible return value\n\n}\n\nfunction serializeInputValue(type, value) {\n  return transformInputValue(type, value, function (t, v) {\n    return t.serialize(v);\n  });\n}\n\nfunction parseInputValue(type, value) {\n  return transformInputValue(type, value, function (t, v) {\n    return t.parseValue(v);\n  });\n}\n\nfunction astFromType(type) {\n  if (isNonNullType(type)) {\n    var innerType = astFromType(type.ofType);\n\n    if (innerType.kind === Kind.NON_NULL_TYPE) {\n      throw new Error(\"Invalid type node \" + JSON.stringify(type) + \". Inner type of non-null type cannot be a non-null type.\");\n    }\n\n    return {\n      kind: Kind.NON_NULL_TYPE,\n      type: innerType\n    };\n  } else if (isListType(type)) {\n    return {\n      kind: Kind.LIST_TYPE,\n      type: astFromType(type.ofType)\n    };\n  }\n\n  return {\n    kind: Kind.NAMED_TYPE,\n    name: {\n      kind: Kind.NAME,\n      value: type.name\n    }\n  };\n}\n\nfunction updateArgument(argName, argType, argumentNodes, variableDefinitionsMap, variableValues, newArg) {\n  var varName;\n  var numGeneratedVariables = 0;\n\n  do {\n    varName = \"_v\" + (numGeneratedVariables++).toString() + \"_\" + argName;\n  } while (varName in variableDefinitionsMap);\n\n  argumentNodes[argName] = {\n    kind: Kind.ARGUMENT,\n    name: {\n      kind: Kind.NAME,\n      value: argName\n    },\n    value: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    }\n  };\n  variableDefinitionsMap[varName] = {\n    kind: Kind.VARIABLE_DEFINITION,\n    variable: {\n      kind: Kind.VARIABLE,\n      name: {\n        kind: Kind.NAME,\n        value: varName\n      }\n    },\n    type: astFromType(argType)\n  };\n  variableValues[varName] = newArg;\n}\n\nfunction toObjMap(obj) {\n  if (Object.getPrototypeOf(obj) === null) {\n    return obj;\n  }\n\n  return Object.entries(obj).reduce(function (map, _a) {\n    var key = _a[0],\n        value = _a[1];\n    map[key] = value;\n    return map;\n  }, Object.create(null));\n}\n\nvar AddArgumentsAsVariables =\n/** @class */\nfunction () {\n  function AddArgumentsAsVariables(targetSchema, args) {\n    this.targetSchema = targetSchema;\n    this.args = toObjMap(args);\n  }\n\n  AddArgumentsAsVariables.prototype.transformRequest = function (originalRequest) {\n    var _a = addVariablesToRootField(this.targetSchema, originalRequest, this.args),\n        document = _a.document,\n        newVariables = _a.newVariables;\n\n    return {\n      document: document,\n      variables: newVariables\n    };\n  };\n\n  return AddArgumentsAsVariables;\n}();\n\nfunction addVariablesToRootField(targetSchema, originalRequest, args) {\n  var document = originalRequest.document;\n  var variableValues = originalRequest.variables;\n  var operations = document.definitions.filter(function (def) {\n    return def.kind === Kind.OPERATION_DEFINITION;\n  });\n  var fragments = document.definitions.filter(function (def) {\n    return def.kind === Kind.FRAGMENT_DEFINITION;\n  });\n  var newOperations = operations.map(function (operation) {\n    var variableDefinitionMap = keyValMap(operation.variableDefinitions, function (def) {\n      return def.variable.name.value;\n    }, function (def) {\n      return def;\n    });\n    var type;\n\n    if (operation.operation === 'subscription') {\n      type = targetSchema.getSubscriptionType();\n    } else if (operation.operation === 'mutation') {\n      type = targetSchema.getMutationType();\n    } else {\n      type = targetSchema.getQueryType();\n    }\n\n    var newSelectionSet = [];\n    operation.selectionSet.selections.forEach(function (selection) {\n      if (selection.kind === Kind.FIELD) {\n        var argumentNodes = selection.arguments;\n        var argumentNodeMap_1 = keyValMap(argumentNodes, function (argument) {\n          return argument.name.value;\n        }, function (argument) {\n          return argument;\n        });\n        var targetField = type.getFields()[selection.name.value]; // excludes __typename\n\n        if (targetField != null) {\n          updateArguments(targetField, argumentNodeMap_1, variableDefinitionMap, variableValues, args);\n        }\n\n        newSelectionSet.push(__assign(__assign({}, selection), {\n          arguments: Object.keys(argumentNodeMap_1).map(function (argName) {\n            return argumentNodeMap_1[argName];\n          })\n        }));\n      } else {\n        newSelectionSet.push(selection);\n      }\n    });\n    return __assign(__assign({}, operation), {\n      variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) {\n        return variableDefinitionMap[varName];\n      }),\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: newSelectionSet\n      }\n    });\n  });\n  return {\n    document: __assign(__assign({}, document), {\n      definitions: __spreadArrays(newOperations, fragments)\n    }),\n    newVariables: variableValues\n  };\n}\n\nfunction updateArguments(targetField, argumentNodeMap, variableDefinitionMap, variableValues, newArgs) {\n  targetField.args.forEach(function (argument) {\n    var argName = argument.name;\n    var argType = argument.type;\n\n    if (argName in newArgs) {\n      updateArgument(argName, argType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(argType, newArgs[argName]));\n    }\n  });\n}\n\nvar version;\n\nif (versionInfo != null && versionInfo.major >= 15) {\n  version = 15;\n} else if (getOperationRootType != null) {\n  version = 14;\n} else if (lexicographicSortSchema != null) {\n  version = 13;\n} else if (printError != null) {\n  version = 12;\n} else {\n  version = 11;\n}\n\nfunction graphqlVersion() {\n  return version;\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction hasOwnProperty(object, propertyName) {\n  return hasOwn.call(object, propertyName);\n} // graphql <v14.2 does not support toConfig\n\n\nfunction schemaToConfig(schema) {\n  if (schema.toConfig != null) {\n    return schema.toConfig();\n  }\n\n  var newTypes = [];\n  var types = schema.getTypeMap();\n  Object.keys(types).forEach(function (typeName) {\n    newTypes.push(types[typeName]);\n  });\n  var schemaConfig = {\n    query: schema.getQueryType(),\n    mutation: schema.getMutationType(),\n    subscription: schema.getSubscriptionType(),\n    types: newTypes,\n    directives: schema.getDirectives().slice(),\n    extensions: schema.extensions,\n    astNode: schema.astNode,\n    extensionASTNodes: schema.extensionASTNodes != null ? schema.extensionASTNodes : [],\n    assumeValid: schema.__validationErrors !== undefined\n  };\n\n  if (graphqlVersion() >= 15) {\n    schemaConfig.description = schema.description;\n  }\n\n  return schemaConfig;\n}\n\nfunction toConfig(graphqlObject) {\n  if (isSchema(graphqlObject)) {\n    return schemaToConfig(graphqlObject);\n  } else if (isDirective(graphqlObject)) {\n    return directiveToConfig(graphqlObject);\n  } else if (isNamedType(graphqlObject)) {\n    return typeToConfig(graphqlObject);\n  } // Input and output fields do not have predicates defined, but using duck typing,\n  // type is defined for input and output fields\n\n\n  if (graphqlObject.type != null) {\n    if (graphqlObject.args != null || graphqlObject.resolve != null || graphqlObject.subscribe != null) {\n      return fieldToConfig(graphqlObject);\n    } else if (graphqlObject.defaultValue !== undefined) {\n      return inputFieldToConfig(graphqlObject);\n    } // Not all input and output fields can be checked by above in older versions\n    // of graphql, but almost all properties on the field and config are identical.\n    // In particular, just name and isDeprecated should be removed.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n    var name_1 = graphqlObject.name,\n        isDeprecated = graphqlObject.isDeprecated,\n        rest = __rest(graphqlObject, [\"name\", \"isDeprecated\"]);\n\n    return __assign({}, rest);\n  }\n\n  throw new Error(\"Unknown graphql object \" + graphqlObject);\n}\n\nfunction typeToConfig(type) {\n  if (isObjectType(type)) {\n    return objectTypeToConfig(type);\n  } else if (isInterfaceType(type)) {\n    return interfaceTypeToConfig(type);\n  } else if (isUnionType(type)) {\n    return unionTypeToConfig(type);\n  } else if (isEnumType(type)) {\n    return enumTypeToConfig(type);\n  } else if (isScalarType(type)) {\n    return scalarTypeToConfig(type);\n  } else if (isInputObjectType(type)) {\n    return inputObjectTypeToConfig(type);\n  }\n\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction objectTypeToConfig(type) {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  var typeConfig = {\n    name: type.name,\n    description: type.description,\n    interfaces: type.getInterfaces(),\n    fields: fieldMapToConfig(type.getFields()),\n    isTypeOf: type.isTypeOf,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : []\n  };\n  return typeConfig;\n}\n\nfunction interfaceTypeToConfig(type) {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  var typeConfig = {\n    name: type.name,\n    description: type.description,\n    fields: fieldMapToConfig(type.getFields()),\n    resolveType: type.resolveType,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : []\n  };\n\n  if (graphqlVersion() >= 15) {\n    typeConfig.interfaces = type.getInterfaces();\n  }\n\n  return typeConfig;\n}\n\nfunction unionTypeToConfig(type) {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  var typeConfig = {\n    name: type.name,\n    description: type.description,\n    types: type.getTypes(),\n    resolveType: type.resolveType,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : []\n  };\n  return typeConfig;\n}\n\nfunction enumTypeToConfig(type) {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  var newValues = keyValMap(type.getValues(), function (value) {\n    return value.name;\n  }, function (value) {\n    return {\n      description: value.description,\n      value: value.value,\n      deprecationReason: value.deprecationReason,\n      extensions: value.extensions,\n      astNode: value.astNode\n    };\n  });\n  var typeConfig = {\n    name: type.name,\n    description: type.description,\n    values: newValues,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : []\n  };\n  return typeConfig;\n}\n\nfunction scalarTypeToConfig(type) {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  var typeConfig = {\n    name: type.name,\n    description: type.description,\n    serialize: graphqlVersion() >= 14 || hasOwnProperty(type, 'serialize') ? type.serialize : type._scalarConfig.serialize,\n    parseValue: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseValue') ? type.parseValue : type._scalarConfig.parseValue,\n    parseLiteral: graphqlVersion() >= 14 || hasOwnProperty(type, 'parseLiteral') ? type.parseLiteral : type._scalarConfig.parseLiteral,\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : []\n  };\n  return typeConfig;\n}\n\nfunction inputObjectTypeToConfig(type) {\n  if (type.toConfig != null) {\n    return type.toConfig();\n  }\n\n  var typeConfig = {\n    name: type.name,\n    description: type.description,\n    fields: inputFieldMapToConfig(type.getFields()),\n    extensions: type.extensions,\n    astNode: type.astNode,\n    extensionASTNodes: type.extensionASTNodes != null ? type.extensionASTNodes : []\n  };\n  return typeConfig;\n}\n\nfunction inputFieldMapToConfig(fields) {\n  return keyValMap(Object.keys(fields), function (fieldName) {\n    return fieldName;\n  }, function (fieldName) {\n    return toConfig(fields[fieldName]);\n  });\n}\n\nfunction inputFieldToConfig(field) {\n  return {\n    description: field.description,\n    type: field.type,\n    defaultValue: field.defaultValue,\n    extensions: field.extensions,\n    astNode: field.astNode\n  };\n}\n\nfunction directiveToConfig(directive) {\n  if (directive.toConfig != null) {\n    return directive.toConfig();\n  }\n\n  var directiveConfig = {\n    name: directive.name,\n    description: directive.description,\n    locations: directive.locations,\n    args: argumentMapToConfig(directive.args),\n    isRepeatable: directive.isRepeatable,\n    extensions: directive.extensions,\n    astNode: directive.astNode\n  };\n  return directiveConfig;\n}\n\nfunction fieldMapToConfig(fields) {\n  return keyValMap(Object.keys(fields), function (fieldName) {\n    return fieldName;\n  }, function (fieldName) {\n    return toConfig(fields[fieldName]);\n  });\n}\n\nfunction fieldToConfig(field) {\n  return {\n    description: field.description,\n    type: field.type,\n    args: argumentMapToConfig(field.args),\n    resolve: field.resolve,\n    subscribe: field.subscribe,\n    deprecationReason: field.deprecationReason,\n    extensions: field.extensions,\n    astNode: field.astNode\n  };\n}\n\nfunction argumentMapToConfig(args) {\n  var newArguments = {};\n  args.forEach(function (arg) {\n    newArguments[arg.name] = argumentToConfig(arg);\n  });\n  return newArguments;\n}\n\nfunction argumentToConfig(arg) {\n  return {\n    description: arg.description,\n    type: arg.type,\n    defaultValue: arg.defaultValue,\n    extensions: arg.extensions,\n    astNode: arg.astNode\n  };\n}\n\nfunction isSpecifiedScalarType(type) {\n  return isNamedType(type) && ( // Would prefer to use specifiedScalarTypes.some(), however %checks needs\n  // a simple expression.\n  type.name === GraphQLString.name || type.name === GraphQLInt.name || type.name === GraphQLFloat.name || type.name === GraphQLBoolean.name || type.name === GraphQLID.name);\n}\n\nfunction mapSchema(schema, schemaMapper) {\n  if (schemaMapper === void 0) {\n    schemaMapper = {};\n  }\n\n  var originalTypeMap = schema.getTypeMap();\n  var newTypeMap = Object.create(null);\n  Object.keys(originalTypeMap).forEach(function (typeName) {\n    if (!typeName.startsWith('__')) {\n      var typeMapper = getMapper(schema, schemaMapper, originalTypeMap[typeName]);\n\n      if (typeMapper != null) {\n        var newType = typeMapper(originalTypeMap[typeName], schema);\n        newTypeMap[typeName] = newType !== undefined ? newType : originalTypeMap[typeName];\n      } else {\n        newTypeMap[typeName] = originalTypeMap[typeName];\n      }\n    }\n  });\n  var queryType = schema.getQueryType();\n  var mutationType = schema.getMutationType();\n  var subscriptionType = schema.getSubscriptionType();\n  var newQueryTypeName = queryType != null ? newTypeMap[queryType.name] != null ? newTypeMap[queryType.name].name : undefined : undefined;\n  var newMutationTypeName = mutationType != null ? newTypeMap[mutationType.name] != null ? newTypeMap[mutationType.name].name : undefined : undefined;\n  var newSubscriptionTypeName = subscriptionType != null ? newTypeMap[subscriptionType.name] != null ? newTypeMap[subscriptionType.name].name : undefined : undefined;\n  var originalDirectives = schema.getDirectives();\n  var newDirectives = [];\n  originalDirectives.forEach(function (directive) {\n    var directiveMapper = getMapper(schema, schemaMapper, directive);\n\n    if (directiveMapper != null) {\n      var newDirective = directiveMapper(directive, schema);\n\n      if (newDirective != null) {\n        newDirectives.push(newDirective);\n      }\n    } else {\n      newDirectives.push(directive);\n    }\n  });\n\n  var _a = rewireTypes(newTypeMap, newDirectives),\n      typeMap = _a.typeMap,\n      directives = _a.directives;\n\n  return new GraphQLSchema(__assign(__assign({}, toConfig(schema)), {\n    query: newQueryTypeName ? typeMap[newQueryTypeName] : undefined,\n    mutation: newMutationTypeName ? typeMap[newMutationTypeName] : undefined,\n    subscription: newSubscriptionTypeName != null ? typeMap[newSubscriptionTypeName] : undefined,\n    types: Object.keys(typeMap).map(function (typeName) {\n      return typeMap[typeName];\n    }),\n    directives: directives\n  }));\n}\n\nfunction getTypeSpecifiers(type, schema) {\n  var specifiers = [MapperKind.TYPE];\n\n  if (isObjectType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.OBJECT_TYPE);\n    var query = schema.getQueryType();\n    var mutation = schema.getMutationType();\n    var subscription = schema.getSubscriptionType();\n\n    if (type === query) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(MapperKind.ROOT_OBJECT, MapperKind.SUBSCRIPTION);\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(MapperKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.INTERFACE_TYPE);\n  } else if (isUnionType(type)) {\n    specifiers.push(MapperKind.COMPOSITE_TYPE, MapperKind.ABSTRACT_TYPE, MapperKind.UNION_TYPE);\n  } else if (isEnumType(type)) {\n    specifiers.push(MapperKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(MapperKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getMapper(schema, schemaMapper, typeOrDirective) {\n  if (isNamedType(typeOrDirective)) {\n    var specifiers = getTypeSpecifiers(typeOrDirective, schema);\n    var typeMapper = void 0;\n\n    var stack = __spreadArrays(specifiers);\n\n    while (!typeMapper && stack.length > 0) {\n      var next = stack.pop();\n      typeMapper = schemaMapper[next];\n    }\n\n    return typeMapper != null ? typeMapper : null;\n  } else if (isDirective(typeOrDirective)) {\n    var directiveMapper = schemaMapper[MapperKind.DIRECTIVE];\n    return directiveMapper != null ? directiveMapper : null;\n  }\n}\n\nfunction rewireTypes(originalTypeMap, directives) {\n  var newTypeMap = Object.create(null);\n  Object.keys(originalTypeMap).forEach(function (typeName) {\n    var namedType = originalTypeMap[typeName];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    var newName = namedType.name;\n\n    if (newName.startsWith('__')) {\n      return;\n    }\n\n    if (newTypeMap[newName] != null) {\n      throw new Error(\"Duplicate schema type name \" + newName);\n    }\n\n    newTypeMap[newName] = namedType;\n  });\n  Object.keys(newTypeMap).forEach(function (typeName) {\n    newTypeMap[typeName] = rewireNamedType(newTypeMap[typeName]);\n  });\n  var newDirectives = directives.map(function (directive) {\n    return rewireDirective(directive);\n  });\n  return pruneTypes(newTypeMap, newDirectives);\n\n  function rewireDirective(directive) {\n    var directiveConfig = toConfig(directive);\n    directiveConfig.args = rewireArgs(directiveConfig.args);\n    return new GraphQLDirective(directiveConfig);\n  }\n\n  function rewireArgs(args) {\n    var rewiredArgs = {};\n    Object.keys(args).forEach(function (argName) {\n      var arg = args[argName];\n      var rewiredArgType = rewireType(arg.type);\n\n      if (rewiredArgType != null) {\n        arg.type = rewiredArgType;\n        rewiredArgs[argName] = arg;\n      }\n    });\n    return rewiredArgs;\n  }\n\n  function rewireNamedType(type) {\n    if (isObjectType(type)) {\n      var config_1 = toConfig(type);\n\n      var newConfig = __assign(__assign({}, config_1), {\n        fields: function fields() {\n          return rewireFields(config_1.fields);\n        },\n        interfaces: function interfaces() {\n          return rewireNamedTypes(config_1.interfaces);\n        }\n      });\n\n      return new GraphQLObjectType(newConfig);\n    } else if (isInterfaceType(type)) {\n      var config_2 = toConfig(type);\n\n      var newConfig = __assign(__assign({}, config_2), {\n        fields: function fields() {\n          return rewireFields(config_2.fields);\n        }\n      });\n\n      if (graphqlVersion() >= 15) {\n        newConfig.interfaces = function () {\n          return rewireNamedTypes(config_2.interfaces);\n        };\n      }\n\n      return new GraphQLInterfaceType(newConfig);\n    } else if (isUnionType(type)) {\n      var config_3 = toConfig(type);\n\n      var newConfig = __assign(__assign({}, config_3), {\n        types: function types() {\n          return rewireNamedTypes(config_3.types);\n        }\n      });\n\n      return new GraphQLUnionType(newConfig);\n    } else if (isInputObjectType(type)) {\n      var config_4 = toConfig(type);\n\n      var newConfig = __assign(__assign({}, config_4), {\n        fields: function fields() {\n          return rewireInputFields(config_4.fields);\n        }\n      });\n\n      return new GraphQLInputObjectType(newConfig);\n    } else if (isEnumType(type)) {\n      var enumConfig = toConfig(type);\n      return new GraphQLEnumType(enumConfig);\n    } else if (isScalarType(type)) {\n      if (isSpecifiedScalarType(type)) {\n        return type;\n      }\n\n      var scalarConfig = toConfig(type);\n      return new GraphQLScalarType(scalarConfig);\n    }\n\n    throw new Error(\"Unexpected schema type: \" + type);\n  }\n\n  function rewireFields(fields) {\n    var rewiredFields = {};\n    Object.keys(fields).forEach(function (fieldName) {\n      var field = fields[fieldName];\n      var rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        field.args = rewireArgs(field.args);\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireInputFields(fields) {\n    var rewiredFields = {};\n    Object.keys(fields).forEach(function (fieldName) {\n      var field = fields[fieldName];\n      var rewiredFieldType = rewireType(field.type);\n\n      if (rewiredFieldType != null) {\n        field.type = rewiredFieldType;\n        rewiredFields[fieldName] = field;\n      }\n    });\n    return rewiredFields;\n  }\n\n  function rewireNamedTypes(namedTypes) {\n    var rewiredTypes = [];\n    namedTypes.forEach(function (namedType) {\n      var rewiredType = rewireType(namedType);\n\n      if (rewiredType != null) {\n        rewiredTypes.push(rewiredType);\n      }\n    });\n    return rewiredTypes;\n  }\n\n  function rewireType(type) {\n    if (isListType(type)) {\n      var rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLList(rewiredType) : null;\n    } else if (isNonNullType(type)) {\n      var rewiredType = rewireType(type.ofType);\n      return rewiredType != null ? new GraphQLNonNull(rewiredType) : null;\n    } else if (isNamedType(type)) {\n      var originalType = originalTypeMap[type.name];\n      return originalType != null ? newTypeMap[originalType.name] : null;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes(typeMap, directives) {\n  var newTypeMap = {};\n  var implementedInterfaces = {};\n  Object.keys(typeMap).forEach(function (typeName) {\n    var namedType = typeMap[typeName];\n\n    if (isObjectType(namedType) || graphqlVersion() >= 15 && isInterfaceType(namedType)) {\n      namedType.getInterfaces().forEach(function (iface) {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n  var prunedTypeMap = false;\n  var typeNames = Object.keys(typeMap);\n\n  for (var i = 0; i < typeNames.length; i++) {\n    var typeName = typeNames[i];\n    var type = typeMap[typeName];\n\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (Object.keys(type.getFields()).length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (type.getTypes().length) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (Object.keys(type.getFields()).length && implementedInterfaces[type.name]) {\n        newTypeMap[typeName] = type;\n      } else {\n        prunedTypeMap = true;\n      }\n    } else {\n      newTypeMap[typeName] = type;\n    }\n  } // every prune requires another round of healing\n\n\n  return prunedTypeMap ? rewireTypes(newTypeMap, directives) : {\n    typeMap: typeMap,\n    directives: directives\n  };\n}\n\nfunction filterSchema(_a) {\n  var _b;\n\n  var schema = _a.schema,\n      _c = _a.rootFieldFilter,\n      rootFieldFilter = _c === void 0 ? function () {\n    return true;\n  } : _c,\n      _d = _a.typeFilter,\n      typeFilter = _d === void 0 ? function () {\n    return true;\n  } : _d,\n      _e = _a.fieldFilter,\n      fieldFilter = _e === void 0 ? function () {\n    return true;\n  } : _e;\n  var filteredSchema = mapSchema(schema, (_b = {}, _b[MapperKind.QUERY] = function (type) {\n    return filterRootFields(type, 'Query', rootFieldFilter);\n  }, _b[MapperKind.MUTATION] = function (type) {\n    return filterRootFields(type, 'Mutation', rootFieldFilter);\n  }, _b[MapperKind.SUBSCRIPTION] = function (type) {\n    return filterRootFields(type, 'Subscription', rootFieldFilter);\n  }, _b[MapperKind.OBJECT_TYPE] = function (type) {\n    return typeFilter(type.name, type) ? filterObjectFields(type, fieldFilter) : null;\n  }, _b[MapperKind.INTERFACE_TYPE] = function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }, _b[MapperKind.UNION_TYPE] = function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }, _b[MapperKind.INPUT_OBJECT_TYPE] = function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }, _b[MapperKind.ENUM_TYPE] = function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }, _b[MapperKind.SCALAR_TYPE] = function (type) {\n    return typeFilter(type.name, type) ? undefined : null;\n  }, _b));\n  filteredSchema.transforms = schema.transforms;\n  return filteredSchema;\n}\n\nfunction filterRootFields(type, operation, rootFieldFilter) {\n  var config = toConfig(type);\n  Object.keys(config.fields).forEach(function (fieldName) {\n    if (!rootFieldFilter(operation, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction filterObjectFields(type, fieldFilter) {\n  var config = toConfig(type);\n  Object.keys(config.fields).forEach(function (fieldName) {\n    if (!fieldFilter(type.name, fieldName, config.fields[fieldName])) {\n      delete config.fields[fieldName];\n    }\n  });\n  return new GraphQLObjectType(config);\n}\n\nfunction cloneDirective(directive) {\n  return new GraphQLDirective(toConfig(directive));\n}\n\nfunction cloneType(type) {\n  if (isObjectType(type)) {\n    var config = toConfig(type);\n    return new GraphQLObjectType(__assign(__assign({}, config), {\n      interfaces: typeof config.interfaces === 'function' ? config.interfaces : config.interfaces.slice()\n    }));\n  } else if (isInterfaceType(type)) {\n    var config = toConfig(type);\n\n    var newConfig = __assign(__assign({}, config), {\n      interfaces: graphqlVersion() >= 15 ? typeof config.interfaces === 'function' ? config.interfaces : config.interfaces.slice() : undefined\n    });\n\n    return new GraphQLInterfaceType(newConfig);\n  } else if (isUnionType(type)) {\n    var config = toConfig(type);\n    return new GraphQLUnionType(__assign(__assign({}, config), {\n      types: config.types.slice()\n    }));\n  } else if (isInputObjectType(type)) {\n    return new GraphQLInputObjectType(toConfig(type));\n  } else if (isEnumType(type)) {\n    return new GraphQLEnumType(toConfig(type));\n  } else if (isScalarType(type)) {\n    return isSpecifiedScalarType(type) ? type : new GraphQLScalarType(toConfig(type));\n  }\n\n  throw new Error(\"Invalid type \" + type);\n}\n\nfunction cloneSchema(schema) {\n  return mapSchema(schema);\n} // polyfill for graphql prior to v13 which do not pass options to buildASTSchema\n\n\nfunction buildSchema(ast, buildSchemaOptions) {\n  return buildASTSchema(parse(ast), buildSchemaOptions);\n}\n\nfunction getResolversFromSchema(schema) {\n  var resolvers = Object.create({});\n  var typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(function (typeName) {\n    var type = typeMap[typeName];\n\n    if (isScalarType(type)) {\n      if (!isSpecifiedScalarType(type)) {\n        resolvers[typeName] = cloneType(type);\n      }\n    } else if (isEnumType(type)) {\n      resolvers[typeName] = {};\n      var values = type.getValues();\n      values.forEach(function (value) {\n        resolvers[typeName][value.name] = value.value;\n      });\n    } else if (isInterfaceType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType\n        };\n      }\n    } else if (isUnionType(type)) {\n      if (type.resolveType != null) {\n        resolvers[typeName] = {\n          __resolveType: type.resolveType\n        };\n      }\n    } else if (isObjectType(type)) {\n      resolvers[typeName] = {};\n\n      if (type.isTypeOf != null) {\n        resolvers[typeName].__isTypeOf = type.isTypeOf;\n      }\n\n      var fields_1 = type.getFields();\n      Object.keys(fields_1).forEach(function (fieldName) {\n        var field = fields_1[fieldName];\n        resolvers[typeName][fieldName] = {\n          resolve: field.resolve,\n          subscribe: field.subscribe\n        };\n      });\n    }\n  });\n  return resolvers;\n} // polyfill for graphql < v14.2 which does not support subscriptions\n\n\nfunction extendSchema(schema, extension, options) {\n  var subscriptionType = schema.getSubscriptionType();\n\n  if (subscriptionType == null) {\n    return extendSchema$1(schema, extension, options);\n  }\n\n  var resolvers = getResolversFromSchema(schema);\n  var subscriptionTypeName = subscriptionType.name;\n  var subscriptionResolvers = resolvers[subscriptionTypeName];\n  var extendedSchema = extendSchema$1(schema, extension, options);\n  var fields = extendedSchema.getSubscriptionType().getFields();\n  Object.keys(subscriptionResolvers).forEach(function (fieldName) {\n    fields[fieldName].subscribe = subscriptionResolvers[fieldName].subscribe;\n  });\n  return extendedSchema;\n} // A generic updater function for arrays or objects.\n\n\nfunction updateEachKey(arrayOrObject, // The callback can return nothing or undefined to leave the key untouched, null to remove\n// the key from the array or object, or a non-null V to replace the value.\nupdater) {\n  var deletedCount = 0;\n  Object.keys(arrayOrObject).forEach(function (key) {\n    var result = updater(arrayOrObject[key], key);\n\n    if (typeof result === 'undefined') {\n      return;\n    }\n\n    if (result === null) {\n      delete arrayOrObject[key];\n      deletedCount++;\n      return;\n    }\n\n    arrayOrObject[key] = result;\n  });\n\n  if (deletedCount > 0 && Array.isArray(arrayOrObject)) {\n    // Remove any holes from the array due to deleted elements.\n    arrayOrObject.splice(0).forEach(function (elem) {\n      arrayOrObject.push(elem);\n    });\n  }\n}\n\nfunction createNamedStub(name, type) {\n  var constructor;\n\n  if (type === 'object') {\n    constructor = GraphQLObjectType;\n  } else if (type === 'interface') {\n    constructor = GraphQLInterfaceType;\n  } else {\n    constructor = GraphQLInputObjectType;\n  }\n\n  return new constructor({\n    name: name,\n    fields: {\n      __fake: {\n        type: GraphQLString\n      }\n    }\n  });\n}\n\nfunction createStub(node, type) {\n  switch (node.kind) {\n    case Kind.LIST_TYPE:\n      return new GraphQLList(createStub(node.type, type));\n\n    case Kind.NON_NULL_TYPE:\n      return new GraphQLNonNull(createStub(node.type, type));\n\n    default:\n      if (type === 'output') {\n        return createNamedStub(node.name.value, 'object');\n      }\n\n      return createNamedStub(node.name.value, 'input');\n  }\n}\n\nfunction isNamedStub(type) {\n  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {\n    var fields = type.getFields();\n    var fieldNames = Object.keys(fields);\n    return fieldNames.length === 1 && fields[fieldNames[0]].name === '__fake';\n  }\n\n  return false;\n}\n\nfunction getBuiltInForStub(type) {\n  switch (type.name) {\n    case GraphQLInt.name:\n      return GraphQLInt;\n\n    case GraphQLFloat.name:\n      return GraphQLFloat;\n\n    case GraphQLString.name:\n      return GraphQLString;\n\n    case GraphQLBoolean.name:\n      return GraphQLBoolean;\n\n    case GraphQLID.name:\n      return GraphQLID;\n\n    default:\n      return type;\n  }\n} // Update any references to named schema types that disagree with the named\n// types found in schema.getTypeMap().\n\n\nfunction healSchema(schema) {\n  var typeMap = schema.getTypeMap();\n  var directives = schema.getDirectives();\n  var queryType = schema.getQueryType();\n  var mutationType = schema.getMutationType();\n  var subscriptionType = schema.getSubscriptionType();\n  var newQueryTypeName = queryType != null ? typeMap[queryType.name] != null ? typeMap[queryType.name].name : undefined : undefined;\n  var newMutationTypeName = mutationType != null ? typeMap[mutationType.name] != null ? typeMap[mutationType.name].name : undefined : undefined;\n  var newSubscriptionTypeName = subscriptionType != null ? typeMap[subscriptionType.name] != null ? typeMap[subscriptionType.name].name : undefined : undefined;\n  healTypes(typeMap, directives);\n  var filteredTypeMap = {};\n  Object.keys(typeMap).forEach(function (typeName) {\n    if (!typeName.startsWith('__')) {\n      filteredTypeMap[typeName] = typeMap[typeName];\n    }\n  });\n  var healedSchema = new GraphQLSchema(__assign(__assign({}, toConfig(schema)), {\n    query: newQueryTypeName ? filteredTypeMap[newQueryTypeName] : undefined,\n    mutation: newMutationTypeName ? filteredTypeMap[newMutationTypeName] : undefined,\n    subscription: newSubscriptionTypeName ? filteredTypeMap[newSubscriptionTypeName] : undefined,\n    types: Object.keys(filteredTypeMap).map(function (typeName) {\n      return filteredTypeMap[typeName];\n    }),\n    directives: directives.slice()\n  })); // Reconstruct the schema to reinitialize private variables\n  // e.g. the stored implementation map and the proper root types.\n\n  Object.assign(schema, healedSchema);\n  return schema;\n}\n\nfunction healTypes(originalTypeMap, directives, config) {\n  if (config === void 0) {\n    config = {\n      skipPruning: false\n    };\n  }\n\n  var actualNamedTypeMap = Object.create(null); // If any of the .name properties of the GraphQLNamedType objects in\n  // schema.getTypeMap() have changed, the keys of the type map need to\n  // be updated accordingly.\n\n  Object.entries(originalTypeMap).forEach(function (_a) {\n    var typeName = _a[0],\n        namedType = _a[1];\n\n    if (namedType == null || typeName.startsWith('__')) {\n      return;\n    }\n\n    var actualName = namedType.name;\n\n    if (actualName.startsWith('__')) {\n      return;\n    }\n\n    if (actualName in actualNamedTypeMap) {\n      throw new Error(\"Duplicate schema type name \" + actualName);\n    }\n\n    actualNamedTypeMap[actualName] = namedType; // Note: we are deliberately leaving namedType in the schema by its\n    // original name (which might be different from actualName), so that\n    // references by that name can be healed.\n  }); // Now add back every named type by its actual name.\n\n  Object.entries(actualNamedTypeMap).forEach(function (_a) {\n    var typeName = _a[0],\n        namedType = _a[1];\n    originalTypeMap[typeName] = namedType;\n  }); // Directive declaration argument types can refer to named types.\n\n  directives.forEach(function (decl) {\n    updateEachKey(decl.args, function (arg) {\n      arg.type = healType(arg.type);\n      return arg.type === null ? null : arg;\n    });\n  });\n  Object.entries(originalTypeMap).forEach(function (_a) {\n    var typeName = _a[0],\n        namedType = _a[1]; // Heal all named types, except for dangling references, kept only to redirect.\n\n    if (!typeName.startsWith('__') && typeName in actualNamedTypeMap) {\n      if (namedType != null) {\n        healNamedType(namedType);\n      }\n    }\n  });\n  updateEachKey(originalTypeMap, function (_namedType, typeName) {\n    // Dangling references to renamed types should remain in the schema\n    // during healing, but must be removed now, so that the following\n    // invariant holds for all names: schema.getType(name).name === name\n    if (!typeName.startsWith('__') && !(typeName in actualNamedTypeMap)) {\n      return null;\n    }\n  });\n\n  if (!config.skipPruning) {\n    pruneTypes$1(originalTypeMap, directives);\n  }\n\n  function healNamedType(type) {\n    if (isObjectType(type)) {\n      healFields(type);\n      healInterfaces(type);\n      return;\n    } else if (isInterfaceType(type)) {\n      healFields(type);\n\n      if (graphqlVersion() >= 15) {\n        healInterfaces(type);\n      }\n\n      return;\n    } else if (isUnionType(type)) {\n      healUnderlyingTypes(type);\n      return;\n    } else if (isInputObjectType(type)) {\n      healInputFields(type);\n      return;\n    } else if (isLeafType(type)) {\n      return;\n    }\n\n    throw new Error(\"Unexpected schema type: \" + type);\n  }\n\n  function healFields(type) {\n    updateEachKey(type.getFields(), function (field) {\n      updateEachKey(field.args, function (arg) {\n        arg.type = healType(arg.type);\n        return arg.type === null ? null : arg;\n      });\n      field.type = healType(field.type);\n      return field.type === null ? null : field;\n    });\n  }\n\n  function healInterfaces(type) {\n    updateEachKey(type.getInterfaces(), function (iface) {\n      var healedType = healType(iface);\n      return healedType;\n    });\n  }\n\n  function healInputFields(type) {\n    updateEachKey(type.getFields(), function (field) {\n      field.type = healType(field.type);\n      return field.type === null ? null : field;\n    });\n  }\n\n  function healUnderlyingTypes(type) {\n    updateEachKey(type.getTypes(), function (t) {\n      var healedType = healType(t);\n      return healedType;\n    });\n  }\n\n  function healType(type) {\n    // Unwrap the two known wrapper types\n    if (isListType(type)) {\n      var healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLList(healedType) : null;\n    } else if (isNonNullType(type)) {\n      var healedType = healType(type.ofType);\n      return healedType != null ? new GraphQLNonNull(healedType) : null;\n    } else if (isNamedType(type)) {\n      // If a type annotation on a field or an argument or a union member is\n      // any `GraphQLNamedType` with a `name`, then it must end up identical\n      // to `schema.getType(name)`, since `schema.getTypeMap()` is the source\n      // of truth for all named schema types.\n      // Note that new types can still be simply added by adding a field, as\n      // the official type will be undefined, not null.\n      var officialType = originalTypeMap[type.name];\n\n      if (officialType === undefined) {\n        if (isNamedStub(type)) {\n          officialType = getBuiltInForStub(type);\n        } else {\n          officialType = type;\n        }\n\n        originalTypeMap[type.name] = officialType;\n      }\n\n      return officialType;\n    }\n\n    return null;\n  }\n}\n\nfunction pruneTypes$1(typeMap, directives) {\n  var implementedInterfaces = {};\n  Object.values(typeMap).forEach(function (namedType) {\n    if (isObjectType(namedType) || graphqlVersion() >= 15 && isInterfaceType(namedType)) {\n      namedType.getInterfaces().forEach(function (iface) {\n        implementedInterfaces[iface.name] = true;\n      });\n    }\n  });\n  var prunedTypeMap = false;\n  var typeNames = Object.keys(typeMap);\n\n  for (var i = 0; i < typeNames.length; i++) {\n    var typeName = typeNames[i];\n    var type = typeMap[typeName];\n\n    if (isObjectType(type) || isInputObjectType(type)) {\n      // prune types with no fields\n      if (!Object.keys(type.getFields()).length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isUnionType(type)) {\n      // prune unions without underlying types\n      if (!type.getTypes().length) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    } else if (isInterfaceType(type)) {\n      // prune interfaces without fields or without implementations\n      if (!Object.keys(type.getFields()).length || !(type.name in implementedInterfaces)) {\n        typeMap[typeName] = null;\n        prunedTypeMap = true;\n      }\n    }\n  } // every prune requires another round of healing\n\n\n  if (prunedTypeMap) {\n    healTypes(typeMap, directives);\n  }\n} // Abstract base class of any visitor implementation, defining the available\n// visitor methods along with their parameter types, and providing a static\n// helper function for determining whether a subclass implements a given\n// visitor method, as opposed to inheriting one of the stubs defined here.\n\n\nvar SchemaVisitor =\n/** @class */\nfunction () {\n  function SchemaVisitor() {} // Determine if this SchemaVisitor (sub)class implements a particular\n  // visitor method.\n\n\n  SchemaVisitor.implementsVisitorMethod = function (methodName) {\n    if (!methodName.startsWith('visit')) {\n      return false;\n    }\n\n    var method = this.prototype[methodName];\n\n    if (typeof method !== 'function') {\n      return false;\n    }\n\n    if (this === SchemaVisitor) {\n      // The SchemaVisitor class implements every visitor method.\n      return true;\n    }\n\n    var stub = SchemaVisitor.prototype[methodName];\n\n    if (method === stub) {\n      // If this.prototype[methodName] was just inherited from SchemaVisitor,\n      // then this class does not really implement the method.\n      return false;\n    }\n\n    return true;\n  }; // Concrete subclasses of SchemaVisitor should override one or more of these\n  // visitor methods, in order to express their interest in handling certain\n  // schema types/locations. Each method may return null to remove the given\n  // type from the schema, a non-null value of the same type to update the\n  // type in the schema, or nothing to leave the type as it was.\n  // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  SchemaVisitor.prototype.visitSchema = function (_schema) {};\n\n  SchemaVisitor.prototype.visitScalar = function (_scalar) {};\n\n  SchemaVisitor.prototype.visitObject = function (_object) {};\n\n  SchemaVisitor.prototype.visitFieldDefinition = function (_field, _details) {};\n\n  SchemaVisitor.prototype.visitArgumentDefinition = function (_argument, _details) {};\n\n  SchemaVisitor.prototype.visitInterface = function (_iface) {}; // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  SchemaVisitor.prototype.visitUnion = function (_union) {}; // eslint-disable-next-line @typescript-eslint/no-empty-function\n\n\n  SchemaVisitor.prototype.visitEnum = function (_type) {};\n\n  SchemaVisitor.prototype.visitEnumValue = function (_value, _details) {};\n\n  SchemaVisitor.prototype.visitInputObject = function (_object) {};\n\n  SchemaVisitor.prototype.visitInputFieldDefinition = function (_field, _details) {};\n\n  return SchemaVisitor;\n}();\n/**\r\n * Creates a keyed JS object from an array, given a function to produce the keys\r\n * for each value in the array.\r\n *\r\n * This provides a convenient lookup for the array items if the key function\r\n * produces unique results.\r\n *\r\n *     const phoneBook = [\r\n *       { name: 'Jon', num: '555-1234' },\r\n *       { name: 'Jenny', num: '867-5309' }\r\n *     ]\r\n *\r\n *     // { Jon: { name: 'Jon', num: '555-1234' },\r\n *     //   Jenny: { name: 'Jenny', num: '867-5309' } }\r\n *     const entriesByName = keyMap(\r\n *       phoneBook,\r\n *       entry => entry.name\r\n *     )\r\n *\r\n *     // { name: 'Jenny', num: '857-6309' }\r\n *     const jennyEntry = entriesByName['Jenny']\r\n *\r\n */\n\n\nfunction keyMap(list, keyFn) {\n  return list.reduce(function (map, item) {\n    map[keyFn(item)] = item;\n    return map;\n  }, Object.create(null));\n} // Similar to the graphql-js function of the same name, slightly simplified:\n// https://github.com/graphql/graphql-js/blob/master/src/utilities/valueFromASTUntyped.js\n\n\nfunction valueFromASTUntyped(valueNode) {\n  switch (valueNode.kind) {\n    case Kind.NULL:\n      return null;\n\n    case Kind.INT:\n      return parseInt(valueNode.value, 10);\n\n    case Kind.FLOAT:\n      return parseFloat(valueNode.value);\n\n    case Kind.STRING:\n    case Kind.ENUM:\n    case Kind.BOOLEAN:\n      return valueNode.value;\n\n    case Kind.LIST:\n      return valueNode.values.map(valueFromASTUntyped);\n\n    case Kind.OBJECT:\n      {\n        return keyValMap(valueNode.fields, function (field) {\n          return field.name.value;\n        }, function (field) {\n          return valueFromASTUntyped(field.value);\n        });\n      }\n\n    /* istanbul ignore next */\n\n    default:\n      throw new Error('Unexpected value kind: ' + valueNode.kind);\n  }\n} // Generic function for visiting GraphQLSchema objects.\n\n\nfunction visitSchema(schema, // To accommodate as many different visitor patterns as possible, the\n// visitSchema function does not simply accept a single instance of the\n// SchemaVisitor class, but instead accepts a function that takes the\n// current VisitableSchemaType object and the name of a visitor method and\n// returns an array of SchemaVisitor instances that implement the visitor\n// method and have an interest in handling the given VisitableSchemaType\n// object. In the simplest case, this function can always return an array\n// containing a single visitor object, without even looking at the type or\n// methodName parameters. In other cases, this function might sometimes\n// return an empty array to indicate there are no visitors that should be\n// applied to the given VisitableSchemaType object. For an example of a\n// visitor pattern that benefits from this abstraction, see the\n// SchemaDirectiveVisitor class below.\nvisitorOrVisitorSelector) {\n  var visitorSelector = typeof visitorOrVisitorSelector === 'function' ? visitorOrVisitorSelector : function () {\n    return visitorOrVisitorSelector;\n  }; // Helper function that calls visitorSelector and applies the resulting\n  // visitors to the given type, with arguments [type, ...args].\n\n  function callMethod(methodName, type) {\n    var args = [];\n\n    for (var _i = 2; _i < arguments.length; _i++) {\n      args[_i - 2] = arguments[_i];\n    }\n\n    var visitors = visitorSelector(type, methodName);\n    visitors = Array.isArray(visitors) ? visitors : [visitors];\n    var finalType = type;\n    visitors.every(function (visitorOrVisitorDef) {\n      var newType;\n\n      if (visitorOrVisitorDef instanceof SchemaVisitor) {\n        newType = visitorOrVisitorDef[methodName].apply(visitorOrVisitorDef, __spreadArrays([finalType], args));\n      } else if (isNamedType(finalType) && (methodName === 'visitScalar' || methodName === 'visitEnum' || methodName === 'visitObject' || methodName === 'visitInputObject' || methodName === 'visitUnion' || methodName === 'visitInterface')) {\n        var specifiers = getTypeSpecifiers$1(finalType, schema);\n        var typeVisitor = getVisitor(visitorOrVisitorDef, specifiers);\n        newType = typeVisitor != null ? typeVisitor(finalType, schema) : undefined;\n      }\n\n      if (typeof newType === 'undefined') {\n        // Keep going without modifying type.\n        return true;\n      }\n\n      if (methodName === 'visitSchema' || isSchema(finalType)) {\n        throw new Error(\"Method \" + methodName + \" cannot replace schema with \" + newType);\n      }\n\n      if (newType === null) {\n        // Stop the loop and return null form callMethod, which will cause\n        // the type to be removed from the schema.\n        finalType = null;\n        return false;\n      } // Update type to the new type returned by the visitor method, so that\n      // later directives will see the new type, and callMethod will return\n      // the final type.\n\n\n      finalType = newType;\n      return true;\n    }); // If there were no directives for this type object, or if all visitor\n    // methods returned nothing, type will be returned unmodified.\n\n    return finalType;\n  } // Recursive helper function that calls any appropriate visitor methods for\n  // each object in the schema, then traverses the object's children (if any).\n\n\n  function visit(type) {\n    if (isSchema(type)) {\n      // Unlike the other types, the root GraphQLSchema object cannot be\n      // replaced by visitor methods, because that would make life very hard\n      // for SchemaVisitor subclasses that rely on the original schema object.\n      callMethod('visitSchema', type);\n      var typeMap_1 = type.getTypeMap();\n      Object.entries(typeMap_1).forEach(function (_a) {\n        var typeName = _a[0],\n            namedType = _a[1];\n\n        if (!typeName.startsWith('__') && namedType != null) {\n          // Call visit recursively to let it determine which concrete\n          // subclass of GraphQLNamedType we found in the type map.\n          // We do not use updateEachKey because we want to preserve\n          // deleted types in the typeMap so that other types that reference\n          // the deleted types can be healed.\n          typeMap_1[typeName] = visit(namedType);\n        }\n      });\n      return type;\n    }\n\n    if (isObjectType(type)) {\n      // Note that callMethod('visitObject', type) may not actually call any\n      // methods, if there are no @directive annotations associated with this\n      // type, or if this SchemaDirectiveVisitor subclass does not override\n      // the visitObject method.\n      var newObject = callMethod('visitObject', type);\n\n      if (newObject != null) {\n        visitFields(newObject);\n      }\n\n      return newObject;\n    }\n\n    if (isInterfaceType(type)) {\n      var newInterface = callMethod('visitInterface', type);\n\n      if (newInterface != null) {\n        visitFields(newInterface);\n      }\n\n      return newInterface;\n    }\n\n    if (isInputObjectType(type)) {\n      var newInputObject_1 = callMethod('visitInputObject', type);\n\n      if (newInputObject_1 != null) {\n        var fieldMap = newInputObject_1.getFields();\n        updateEachKey(fieldMap, function (field) {\n          return callMethod('visitInputFieldDefinition', field, {\n            // Since we call a different method for input object fields, we\n            // can't reuse the visitFields function here.\n            objectType: newInputObject_1\n          });\n        });\n      }\n\n      return newInputObject_1;\n    }\n\n    if (isScalarType(type)) {\n      return callMethod('visitScalar', type);\n    }\n\n    if (isUnionType(type)) {\n      return callMethod('visitUnion', type);\n    }\n\n    if (isEnumType(type)) {\n      var newEnum_1 = callMethod('visitEnum', type);\n\n      if (newEnum_1 != null) {\n        updateEachKey(newEnum_1.getValues(), function (value) {\n          return callMethod('visitEnumValue', value, {\n            enumType: newEnum_1\n          });\n        });\n      }\n\n      return newEnum_1;\n    }\n\n    throw new Error(\"Unexpected schema type: \" + type);\n  }\n\n  function visitFields(type) {\n    updateEachKey(type.getFields(), function (field) {\n      // It would be nice if we could call visit(field) recursively here, but\n      // GraphQLField is merely a type, not a value that can be detected using\n      // an instanceof check, so we have to visit the fields in this lexical\n      // context, so that TypeScript can validate the call to\n      // visitFieldDefinition.\n      var newField = callMethod('visitFieldDefinition', field, {\n        // While any field visitor needs a reference to the field object, some\n        // field visitors may also need to know the enclosing (parent) type,\n        // perhaps to determine if the parent is a GraphQLObjectType or a\n        // GraphQLInterfaceType. To obtain a reference to the parent, a\n        // visitor method can have a second parameter, which will be an object\n        // with an .objectType property referring to the parent.\n        objectType: type\n      });\n\n      if (newField.args != null) {\n        updateEachKey(newField.args, function (arg) {\n          return callMethod('visitArgumentDefinition', arg, {\n            // Like visitFieldDefinition, visitArgumentDefinition takes a\n            // second parameter that provides additional context, namely the\n            // parent .field and grandparent .objectType. Remember that the\n            // current GraphQLSchema is always available via this.schema.\n            field: newField,\n            objectType: type\n          });\n        });\n      }\n\n      return newField;\n    });\n  }\n\n  visit(schema); // Automatically update any references to named schema types replaced\n  // during the traversal, so implementors don't have to worry about that.\n\n  healSchema(schema); // Return schema for convenience, even though schema parameter has all updated types.\n\n  return schema;\n}\n\nfunction getTypeSpecifiers$1(type, schema) {\n  var specifiers = [VisitSchemaKind.TYPE];\n\n  if (isObjectType(type)) {\n    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.OBJECT_TYPE);\n    var query = schema.getQueryType();\n    var mutation = schema.getMutationType();\n    var subscription = schema.getSubscriptionType();\n\n    if (type === query) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.QUERY);\n    } else if (type === mutation) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.MUTATION);\n    } else if (type === subscription) {\n      specifiers.push(VisitSchemaKind.ROOT_OBJECT, VisitSchemaKind.SUBSCRIPTION);\n    }\n  } else if (isInputType(type)) {\n    specifiers.push(VisitSchemaKind.INPUT_OBJECT_TYPE);\n  } else if (isInterfaceType(type)) {\n    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.INTERFACE_TYPE);\n  } else if (isUnionType(type)) {\n    specifiers.push(VisitSchemaKind.COMPOSITE_TYPE, VisitSchemaKind.ABSTRACT_TYPE, VisitSchemaKind.UNION_TYPE);\n  } else if (isEnumType(type)) {\n    specifiers.push(VisitSchemaKind.ENUM_TYPE);\n  } else if (isScalarType(type)) {\n    specifiers.push(VisitSchemaKind.SCALAR_TYPE);\n  }\n\n  return specifiers;\n}\n\nfunction getVisitor(visitorDef, specifiers) {\n  var typeVisitor;\n\n  var stack = __spreadArrays(specifiers);\n\n  while (!typeVisitor && stack.length > 0) {\n    var next = stack.pop();\n    typeVisitor = visitorDef[next];\n  }\n\n  return typeVisitor != null ? typeVisitor : null;\n}\n\nvar MAX_ARRAY_LENGTH = 10;\nvar MAX_RECURSIVE_DEPTH = 2;\n/**\r\n * Used to print values in error messages.\r\n */\n\nfunction inspect(value) {\n  return formatValue(value, []);\n}\n\nfunction formatValue(value, seenValues) {\n  switch (_typeof(value)) {\n    case 'string':\n      return JSON.stringify(value);\n\n    case 'function':\n      return value.name ? \"[function \" + value.name + \"]\" : '[function]';\n\n    case 'object':\n      if (value === null) {\n        return 'null';\n      }\n\n      return formatObjectValue(value, seenValues);\n\n    default:\n      return String(value);\n  }\n}\n\nfunction formatObjectValue(value, previouslySeenValues) {\n  if (previouslySeenValues.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  var seenValues = __spreadArrays(previouslySeenValues, [value]);\n\n  var customInspectFn = getCustomFn(value);\n\n  if (customInspectFn !== undefined) {\n    var customValue = customInspectFn.call(value); // check for infinite recursion\n\n    if (customValue !== value) {\n      return typeof customValue === 'string' ? customValue : formatValue(customValue, seenValues);\n    }\n  } else if (Array.isArray(value)) {\n    return formatArray(value, seenValues);\n  }\n\n  return formatObject(value, seenValues);\n}\n\nfunction formatObject(object, seenValues) {\n  var keys = Object.keys(object);\n\n  if (keys.length === 0) {\n    return '{}';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[' + getObjectTag(object) + ']';\n  }\n\n  var properties = keys.map(function (key) {\n    var value = formatValue(object[key], seenValues);\n    return key + ': ' + value;\n  });\n  return '{ ' + properties.join(', ') + ' }';\n}\n\nfunction formatArray(array, seenValues) {\n  if (array.length === 0) {\n    return '[]';\n  }\n\n  if (seenValues.length > MAX_RECURSIVE_DEPTH) {\n    return '[Array]';\n  }\n\n  var len = Math.min(MAX_ARRAY_LENGTH, array.length);\n  var remaining = array.length - len;\n  var items = [];\n\n  for (var i = 0; i < len; ++i) {\n    items.push(formatValue(array[i], seenValues));\n  }\n\n  if (remaining === 1) {\n    items.push('... 1 more item');\n  } else if (remaining > 1) {\n    items.push(\"... \" + remaining.toString(10) + \" more items\");\n  }\n\n  return '[' + items.join(', ') + ']';\n}\n\nfunction getCustomFn(obj) {\n  if (typeof obj.inspect === 'function') {\n    return obj.inspect;\n  }\n}\n\nfunction getObjectTag(obj) {\n  var tag = Object.prototype.toString.call(obj).replace(/^\\[object /, '').replace(/]$/, '');\n\n  if (tag === 'Object' && typeof obj.constructor === 'function') {\n    var name_1 = obj.constructor.name;\n\n    if (typeof name_1 === 'string' && name_1 !== '') {\n      return name_1;\n    }\n  }\n\n  return tag;\n}\n/**\r\n * Prepares an object map of argument values given a list of argument\r\n * definitions and list of argument AST nodes.\r\n *\r\n * Note: The returned value is a plain Object with a prototype, since it is\r\n * exposed to user code. Care should be taken to not pull values from the\r\n * Object prototype.\r\n */\n\n\nfunction getArgumentValues(def, node, variableValues) {\n  if (variableValues === void 0) {\n    variableValues = {};\n  }\n\n  var _a;\n\n  var variableMap = toObjMap(variableValues);\n  var coercedValues = {}; // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n\n  var argumentNodes = (_a = node.arguments) !== null && _a !== void 0 ? _a : [];\n  var argNodeMap = keyMap(argumentNodes, function (arg) {\n    return arg.name.value;\n  });\n\n  for (var _i = 0, _b = def.args; _i < _b.length; _i++) {\n    var argDef = _b[_i];\n    var name_1 = argDef.name;\n    var argType = argDef.type;\n    var argumentNode = argNodeMap[name_1];\n\n    if (!argumentNode) {\n      if (argDef.defaultValue !== undefined) {\n        coercedValues[name_1] = argDef.defaultValue;\n      } else if (isNonNullType(argType)) {\n        throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" + 'was not provided.', node);\n      }\n\n      continue;\n    }\n\n    var valueNode = argumentNode.value;\n    var isNull = valueNode.kind === Kind.NULL;\n\n    if (valueNode.kind === Kind.VARIABLE) {\n      var variableName = valueNode.name.value;\n\n      if (variableValues == null || !(variableName in variableMap)) {\n        if (argDef.defaultValue !== undefined) {\n          coercedValues[name_1] = argDef.defaultValue;\n        } else if (isNonNullType(argType)) {\n          throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of required type \\\"\" + inspect(argType) + \"\\\" \" + (\"was provided the variable \\\"$\" + variableName + \"\\\" which was not provided a runtime value.\"), valueNode);\n        }\n\n        continue;\n      }\n\n      isNull = variableValues[variableName] == null;\n    }\n\n    if (isNull && isNonNullType(argType)) {\n      throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" of non-null type \\\"\" + inspect(argType) + \"\\\" \" + 'must not be null.', valueNode);\n    }\n\n    var coercedValue = valueFromAST(valueNode, argType, variableValues);\n\n    if (coercedValue === undefined) {\n      // Note: ValuesOfCorrectTypeRule validation should catch this before\n      // execution. This is a runtime check to ensure execution does not\n      // continue with an invalid argument value.\n      throw new GraphQLError(\"Argument \\\"\" + name_1 + \"\\\" has invalid value \" + print(valueNode) + \".\", valueNode);\n    }\n\n    coercedValues[name_1] = coercedValue;\n  }\n\n  return coercedValues;\n} // This class represents a reusable implementation of a @directive that may\n// appear in a GraphQL schema written in Schema Definition Language.\n//\n// By overriding one or more visit{Object,Union,...} methods, a subclass\n// registers interest in certain schema types, such as GraphQLObjectType,\n// GraphQLUnionType, etc. When SchemaDirectiveVisitor.visitSchemaDirectives is\n// called with a GraphQLSchema object and a map of visitor subclasses, the\n// overidden methods of those subclasses allow the visitors to obtain\n// references to any type objects that have @directives attached to them,\n// enabling visitors to inspect or modify the schema as appropriate.\n//\n// For example, if a directive called @rest(url: \"...\") appears after a field\n// definition, a SchemaDirectiveVisitor subclass could provide meaning to that\n// directive by overriding the visitFieldDefinition method (which receives a\n// GraphQLField parameter), and then the body of that visitor method could\n// manipulate the field's resolver function to fetch data from a REST endpoint\n// described by the url argument passed to the @rest directive:\n//\n//   const typeDefs = `\n//   type Query {\n//     people: [Person] @rest(url: \"/api/v1/people\")\n//   }`;\n//\n//   const schema = makeExecutableSchema({ typeDefs });\n//\n//   SchemaDirectiveVisitor.visitSchemaDirectives(schema, {\n//     rest: class extends SchemaDirectiveVisitor {\n//       public visitFieldDefinition(field: GraphQLField<any, any>) {\n//         const { url } = this.args;\n//         field.resolve = () => fetch(url);\n//       }\n//     }\n//   });\n//\n// The subclass in this example is defined as an anonymous class expression,\n// for brevity. A truly reusable SchemaDirectiveVisitor would most likely be\n// defined in a library using a named class declaration, and then exported for\n// consumption by other modules and packages.\n//\n// See below for a complete list of overridable visitor methods, their\n// parameter types, and more details about the properties exposed by instances\n// of the SchemaDirectiveVisitor class.\n\n\nvar SchemaDirectiveVisitor =\n/** @class */\nfunction (_super) {\n  __extends(SchemaDirectiveVisitor, _super); // Mark the constructor protected to enforce passing SchemaDirectiveVisitor\n  // subclasses (not instances) to visitSchemaDirectives.\n\n\n  function SchemaDirectiveVisitor(config) {\n    var _this = _super.call(this) || this;\n\n    _this.name = config.name;\n    _this.args = config.args;\n    _this.visitedType = config.visitedType;\n    _this.schema = config.schema;\n    _this.context = config.context;\n    return _this;\n  } // Override this method to return a custom GraphQLDirective (or modify one\n  // already present in the schema) to enforce argument types, provide default\n  // argument values, or specify schema locations where this @directive may\n  // appear. By default, any declaration found in the schema will be returned.\n\n\n  SchemaDirectiveVisitor.getDirectiveDeclaration = function (directiveName, schema) {\n    return schema.getDirective(directiveName);\n  }; // Call SchemaDirectiveVisitor.visitSchemaDirectives to visit every\n  // @directive in the schema and create an appropriate SchemaDirectiveVisitor\n  // instance to visit the object decorated by the @directive.\n\n\n  SchemaDirectiveVisitor.visitSchemaDirectives = function (schema, // The keys of this object correspond to directive names as they appear\n  // in the schema, and the values should be subclasses (not instances!)\n  // of the SchemaDirectiveVisitor class. This distinction is important\n  // because a new SchemaDirectiveVisitor instance will be created each\n  // time a matching directive is found in the schema AST, with arguments\n  // and other metadata specific to that occurrence. To help prevent the\n  // mistake of passing instances, the SchemaDirectiveVisitor constructor\n  // method is marked as protected.\n  directiveVisitors, // Optional context object that will be available to all visitor instances\n  // via this.context. Defaults to an empty null-prototype object.\n  context) {\n    if (context === void 0) {\n      context = Object.create(null);\n    } // If the schema declares any directives for public consumption, record\n    // them here so that we can properly coerce arguments when/if we encounter\n    // an occurrence of the directive while walking the schema below.\n\n\n    var declaredDirectives = this.getDeclaredDirectives(schema, directiveVisitors); // Map from directive names to lists of SchemaDirectiveVisitor instances\n    // created while visiting the schema.\n\n    var createdVisitors = keyValMap(Object.keys(directiveVisitors), function (item) {\n      return item;\n    }, function () {\n      return [];\n    });\n    var directiveVisitorMap = toObjMap(directiveVisitors);\n\n    function visitorSelector(type, methodName) {\n      var directiveNodes = type.astNode != null ? type.astNode.directives : [];\n      var extensionASTNodes = type.extensionASTNodes;\n\n      if (extensionASTNodes != null) {\n        extensionASTNodes.forEach(function (extensionASTNode) {\n          directiveNodes = directiveNodes.concat(extensionASTNode.directives);\n        });\n      }\n\n      var visitors = [];\n      directiveNodes.forEach(function (directiveNode) {\n        var directiveName = directiveNode.name.value;\n\n        if (!(directiveName in directiveVisitorMap)) {\n          return;\n        }\n\n        var visitorClass = directiveVisitorMap[directiveName]; // Avoid creating visitor objects if visitorClass does not override\n        // the visitor method named by methodName.\n\n        if (!visitorClass.implementsVisitorMethod(methodName)) {\n          return;\n        }\n\n        var decl = declaredDirectives[directiveName];\n        var args;\n\n        if (decl != null) {\n          // If this directive was explicitly declared, use the declared\n          // argument types (and any default values) to check, coerce, and/or\n          // supply default values for the given arguments.\n          args = getArgumentValues(decl, directiveNode);\n        } else {\n          // If this directive was not explicitly declared, just convert the\n          // argument nodes to their corresponding JavaScript values.\n          args = Object.create(null);\n\n          if (directiveNode.arguments != null) {\n            directiveNode.arguments.forEach(function (arg) {\n              args[arg.name.value] = valueFromASTUntyped(arg.value);\n            });\n          }\n        } // As foretold in comments near the top of the visitSchemaDirectives\n        // method, this is where instances of the SchemaDirectiveVisitor class\n        // get created and assigned names. While subclasses could override the\n        // constructor method, the constructor is marked as protected, so\n        // these are the only arguments that will ever be passed.\n\n\n        visitors.push(new visitorClass({\n          name: directiveName,\n          args: args,\n          visitedType: type,\n          schema: schema,\n          context: context\n        }));\n      });\n\n      if (visitors.length > 0) {\n        visitors.forEach(function (visitor) {\n          createdVisitors[visitor.name].push(visitor);\n        });\n      }\n\n      return visitors;\n    }\n\n    visitSchema(schema, visitorSelector);\n    return createdVisitors;\n  };\n\n  SchemaDirectiveVisitor.getDeclaredDirectives = function (schema, directiveVisitors) {\n    var directiveVisitorMap = toObjMap(directiveVisitors);\n    var declaredDirectives = keyMap(schema.getDirectives(), function (d) {\n      return d.name;\n    }); // If the visitor subclass overrides getDirectiveDeclaration, and it\n    // returns a non-null GraphQLDirective, use that instead of any directive\n    // declared in the schema itself. Reasoning: if a SchemaDirectiveVisitor\n    // goes to the trouble of implementing getDirectiveDeclaration, it should\n    // be able to rely on that implementation.\n\n    Object.entries(directiveVisitors).forEach(function (_a) {\n      var directiveName = _a[0],\n          visitorClass = _a[1];\n      var decl = visitorClass.getDirectiveDeclaration(directiveName, schema);\n\n      if (decl != null) {\n        declaredDirectives[directiveName] = decl;\n      }\n    });\n    Object.entries(declaredDirectives).forEach(function (_a) {\n      var name = _a[0],\n          decl = _a[1];\n\n      if (!(name in directiveVisitorMap)) {\n        // SchemaDirectiveVisitors.visitSchemaDirectives might be called\n        // multiple times with partial directiveVisitors maps, so it's not\n        // necessarily an error for directiveVisitors to be missing an\n        // implementation of a directive that was declared in the schema.\n        return;\n      }\n\n      var visitorClass = directiveVisitorMap[name];\n      decl.locations.forEach(function (loc) {\n        var visitorMethodName = directiveLocationToVisitorMethodName(loc);\n\n        if (SchemaVisitor.implementsVisitorMethod(visitorMethodName) && !visitorClass.implementsVisitorMethod(visitorMethodName)) {\n          // While visitor subclasses may implement extra visitor methods,\n          // it's definitely a mistake if the GraphQLDirective declares itself\n          // applicable to certain schema locations, and the visitor subclass\n          // does not implement all the corresponding methods.\n          throw new Error(\"SchemaDirectiveVisitor for @\" + name + \" must implement \" + visitorMethodName + \" method\");\n        }\n      });\n    });\n    return declaredDirectives;\n  };\n\n  return SchemaDirectiveVisitor;\n}(SchemaVisitor); // Convert a string like \"FIELD_DEFINITION\" to \"visitFieldDefinition\".\n\n\nfunction directiveLocationToVisitorMethodName(loc) {\n  return 'visit' + loc.replace(/([^_]*)_?/g, function (_wholeMatch, part) {\n    return part.charAt(0).toUpperCase() + part.slice(1).toLowerCase();\n  });\n}\n\nfunction forEachField(schema, fn) {\n  var typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(function (typeName) {\n    var type = typeMap[typeName]; // TODO: maybe have an option to include these?\n\n    if (!getNamedType(type).name.startsWith('__') && isObjectType(type)) {\n      var fields_1 = type.getFields();\n      Object.keys(fields_1).forEach(function (fieldName) {\n        var field = fields_1[fieldName];\n        fn(field, typeName, fieldName);\n      });\n    }\n  });\n}\n\nfunction forEachDefaultValue(schema, fn) {\n  var typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(function (typeName) {\n    var type = typeMap[typeName];\n\n    if (!getNamedType(type).name.startsWith('__')) {\n      if (isObjectType(type)) {\n        var fields_1 = type.getFields();\n        Object.keys(fields_1).forEach(function (fieldName) {\n          var field = fields_1[fieldName];\n          field.args.forEach(function (arg) {\n            arg.defaultValue = fn(arg.type, arg.defaultValue);\n          });\n        });\n      } else if (isInputObjectType(type)) {\n        var fields_2 = type.getFields();\n        Object.keys(fields_2).forEach(function (fieldName) {\n          var field = fields_2[fieldName];\n          field.defaultValue = fn(field.type, field.defaultValue);\n        });\n      }\n    }\n  });\n}\n\nfunction applySchemaTransforms(originalSchema, transforms) {\n  return transforms.reduce(function (schema, transform) {\n    return transform.transformSchema != null ? transform.transformSchema(cloneSchema(schema)) : schema;\n  }, originalSchema);\n}\n\nfunction applyRequestTransforms(originalRequest, transforms) {\n  return transforms.reduce(function (request, transform) {\n    return transform.transformRequest != null ? transform.transformRequest(request) : request;\n  }, originalRequest);\n}\n\nfunction applyResultTransforms(originalResult, transforms) {\n  return transforms.reduceRight(function (result, transform) {\n    return transform.transformResult != null ? transform.transformResult(result) : result;\n  }, originalResult);\n}\n\nfunction linkToFetcher(link) {\n  return function (fetcherOperation) {\n    return toPromise(execute(link, fetcherOperation));\n  };\n}\n\nfunction observableToAsyncIterable(observable) {\n  var _a;\n\n  var pullQueue = [];\n  var pushQueue = [];\n  var listening = true;\n\n  var pushValue = function pushValue(value) {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({\n        value: value,\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: value\n      });\n    }\n  };\n\n  var pushError = function pushError(error) {\n    if (pullQueue.length !== 0) {\n      pullQueue.shift()({\n        value: {\n          errors: [error]\n        },\n        done: false\n      });\n    } else {\n      pushQueue.push({\n        value: {\n          errors: [error]\n        }\n      });\n    }\n  };\n\n  var pullValue = function pullValue() {\n    return new Promise(function (resolve) {\n      if (pushQueue.length !== 0) {\n        var element = pushQueue.shift(); // either {value: {errors: [...]}} or {value: ...}\n\n        resolve(__assign(__assign({}, element), {\n          done: false\n        }));\n      } else {\n        pullQueue.push(resolve);\n      }\n    });\n  };\n\n  var subscription = observable.subscribe({\n    next: function next(value) {\n      pushValue(value);\n    },\n    error: function error(err) {\n      pushError(err);\n    }\n  });\n\n  var emptyQueue = function emptyQueue() {\n    if (listening) {\n      listening = false;\n      subscription.unsubscribe();\n      pullQueue.forEach(function (resolve) {\n        return resolve({\n          value: undefined,\n          done: true\n        });\n      });\n      pullQueue.length = 0;\n      pushQueue.length = 0;\n    }\n  };\n\n  return _a = {\n    next: function next() {\n      return listening ? pullValue() : this[\"return\"]();\n    },\n    \"return\": function _return() {\n      emptyQueue();\n      return Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    \"throw\": function _throw(error) {\n      emptyQueue();\n      return Promise.reject(error);\n    }\n  }, _a[$$asyncIterator] = function () {\n    return this;\n  }, _a;\n}\n/**\r\n * Given an AsyncIterable and a callback function, return an AsyncIterator\r\n * which produces values mapped via calling the callback function.\r\n */\n\n\nfunction mapAsyncIterator(iterator, callback, rejectCallback) {\n  var _a;\n\n  var $return;\n  var abruptClose;\n\n  if (typeof iterator[\"return\"] === 'function') {\n    $return = iterator[\"return\"];\n\n    abruptClose = function abruptClose(error) {\n      var rethrow = function rethrow() {\n        return Promise.reject(error);\n      };\n\n      return $return.call(iterator).then(rethrow, rethrow);\n    };\n  }\n\n  function mapResult(result) {\n    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);\n  }\n\n  var mapReject;\n\n  if (rejectCallback) {\n    // Capture rejectCallback to ensure it cannot be null.\n    var reject_1 = rejectCallback;\n\n    mapReject = function mapReject(error) {\n      return asyncMapValue(error, reject_1).then(iteratorResult, abruptClose);\n    };\n  }\n\n  return _a = {\n    next: function next() {\n      return iterator.next().then(mapResult, mapReject);\n    },\n    \"return\": function _return() {\n      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({\n        value: undefined,\n        done: true\n      });\n    },\n    \"throw\": function _throw(error) {\n      if (typeof iterator[\"throw\"] === 'function') {\n        return iterator[\"throw\"](error).then(mapResult, mapReject);\n      }\n\n      return Promise.reject(error)[\"catch\"](abruptClose);\n    }\n  }, _a[$$asyncIterator] = function () {\n    return this;\n  }, _a;\n}\n\nfunction asyncMapValue(value, callback) {\n  return new Promise(function (resolve) {\n    return resolve(callback(value));\n  });\n}\n\nfunction iteratorResult(value) {\n  return {\n    value: value,\n    done: false\n  };\n}\n\nfunction getDelegatingOperation(parentType, schema) {\n  if (parentType === schema.getMutationType()) {\n    return 'mutation';\n  } else if (parentType === schema.getSubscriptionType()) {\n    return 'subscription';\n  }\n\n  return 'query';\n}\n\nfunction createRequestFromInfo(_a) {\n  var info = _a.info,\n      _b = _a.operation,\n      operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b,\n      _c = _a.fieldName,\n      fieldName = _c === void 0 ? info.fieldName : _c,\n      selectionSet = _a.selectionSet,\n      fieldNodes = _a.fieldNodes;\n  return createRequest({\n    sourceSchema: info.schema,\n    sourceParentType: info.parentType,\n    sourceFieldName: info.fieldName,\n    fragments: info.fragments,\n    variableDefinitions: info.operation.variableDefinitions,\n    variableValues: info.variableValues,\n    targetOperation: operation,\n    targetFieldName: fieldName,\n    selectionSet: selectionSet,\n    fieldNodes: selectionSet != null ? undefined : fieldNodes != null ? fieldNodes : info.fieldNodes\n  });\n}\n\nfunction createRequest(_a) {\n  var sourceSchema = _a.sourceSchema,\n      sourceParentType = _a.sourceParentType,\n      sourceFieldName = _a.sourceFieldName,\n      fragments = _a.fragments,\n      variableDefinitions = _a.variableDefinitions,\n      variableValues = _a.variableValues,\n      targetOperation = _a.targetOperation,\n      targetFieldName = _a.targetFieldName,\n      selectionSet = _a.selectionSet,\n      fieldNodes = _a.fieldNodes;\n  var argumentNodes;\n  var newSelectionSet = selectionSet;\n\n  if (!selectionSet && fieldNodes != null) {\n    var selections = fieldNodes.reduce(function (acc, fieldNode) {\n      return fieldNode.selectionSet != null ? acc.concat(fieldNode.selectionSet.selections) : acc;\n    }, []);\n    newSelectionSet = selections.length ? {\n      kind: Kind.SELECTION_SET,\n      selections: selections\n    } : undefined;\n    argumentNodes = fieldNodes[0].arguments;\n  } else {\n    argumentNodes = [];\n  }\n\n  var newVariables = Object.create(null);\n  var variableDefinitionMap = Object.create(null);\n  variableDefinitions.forEach(function (def) {\n    var varName = def.variable.name.value;\n    variableDefinitionMap[varName] = def;\n    var varType = typeFromAST$1(sourceSchema, def.type);\n    newVariables[varName] = serializeInputValue(varType, variableValues[varName]);\n  });\n  var argumentNodeMap = keyMap(argumentNodes, function (arg) {\n    return arg.name.value;\n  });\n  updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, newVariables);\n  var rootfieldNode = {\n    kind: Kind.FIELD,\n    alias: null,\n    arguments: Object.keys(argumentNodeMap).map(function (argName) {\n      return argumentNodeMap[argName];\n    }),\n    selectionSet: newSelectionSet,\n    name: {\n      kind: Kind.NAME,\n      value: targetFieldName || fieldNodes[0].name.value\n    }\n  };\n  var operationDefinition = {\n    kind: Kind.OPERATION_DEFINITION,\n    operation: targetOperation,\n    variableDefinitions: Object.keys(variableDefinitionMap).map(function (varName) {\n      return variableDefinitionMap[varName];\n    }),\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: [rootfieldNode]\n    }\n  };\n  var fragmentDefinitions = Object.keys(fragments).map(function (fragmentName) {\n    return fragments[fragmentName];\n  });\n  var document = {\n    kind: Kind.DOCUMENT,\n    definitions: __spreadArrays([operationDefinition], fragmentDefinitions)\n  };\n  return {\n    document: document,\n    variables: newVariables\n  };\n}\n\nfunction updateArgumentsWithDefaults(sourceParentType, sourceFieldName, argumentNodeMap, variableDefinitionMap, variableValues) {\n  var sourceField = sourceParentType.getFields()[sourceFieldName];\n  sourceField.args.forEach(function (argument) {\n    var argName = argument.name;\n    var sourceArgType = argument.type;\n\n    if (argumentNodeMap[argName] === undefined) {\n      var defaultValue = argument.defaultValue;\n\n      if (defaultValue !== undefined) {\n        updateArgument(argName, sourceArgType, argumentNodeMap, variableDefinitionMap, variableValues, serializeInputValue(sourceArgType, defaultValue));\n      }\n    }\n  });\n}\n\nfunction _delegateToSchema(options) {\n  if (isSchema(options)) {\n    throw new Error('Passing positional arguments to delegateToSchema is deprecated. ' + 'Please pass named parameters instead.');\n  }\n\n  var info = options.info,\n      _a = options.operation,\n      operation = _a === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _a,\n      _b = options.fieldName,\n      fieldName = _b === void 0 ? info.fieldName : _b,\n      _c = options.returnType,\n      returnType = _c === void 0 ? info.returnType : _c,\n      selectionSet = options.selectionSet,\n      fieldNodes = options.fieldNodes;\n  var request = createRequestFromInfo({\n    info: info,\n    operation: operation,\n    fieldName: fieldName,\n    selectionSet: selectionSet,\n    fieldNodes: fieldNodes\n  });\n  return delegateRequest(__assign(__assign({}, options), {\n    request: request,\n    operation: operation,\n    fieldName: fieldName,\n    returnType: returnType\n  }));\n}\n\nfunction buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, transforms, skipTypeMerging) {\n  var delegationTransforms = [new CheckResultAndHandleErrors(info, fieldName, subschemaOrSubschemaConfig, context, returnType, skipTypeMerging)];\n\n  if (info.mergeInfo != null) {\n    delegationTransforms.push(new AddReplacementSelectionSets(info.schema, info.mergeInfo.replacementSelectionSets), new AddMergedTypeFragments(info.schema, info.mergeInfo.mergedTypes));\n  }\n\n  delegationTransforms = delegationTransforms.concat(transforms);\n  delegationTransforms.push(new ExpandAbstractTypes(info.schema, targetSchema));\n\n  if (info.mergeInfo != null) {\n    delegationTransforms.push(new AddReplacementFragments(targetSchema, info.mergeInfo.replacementFragments));\n  }\n\n  if (args != null) {\n    delegationTransforms.push(new AddArgumentsAsVariables(targetSchema, args));\n  }\n\n  delegationTransforms.push(new FilterToSchema(targetSchema), new AddTypenameToAbstract(targetSchema));\n  return delegationTransforms;\n}\n\nfunction delegateRequest(_a) {\n  var request = _a.request,\n      subschemaOrSubschemaConfig = _a.schema,\n      rootValue = _a.rootValue,\n      info = _a.info,\n      _b = _a.operation,\n      operation = _b === void 0 ? getDelegatingOperation(info.parentType, info.schema) : _b,\n      _c = _a.fieldName,\n      fieldName = _c === void 0 ? info.fieldName : _c,\n      args = _a.args,\n      _d = _a.returnType,\n      returnType = _d === void 0 ? info.returnType : _d,\n      context = _a.context,\n      _e = _a.transforms,\n      transforms = _e === void 0 ? [] : _e,\n      skipValidation = _a.skipValidation,\n      skipTypeMerging = _a.skipTypeMerging;\n  var targetSchema;\n  var targetRootValue;\n  var requestTransforms = transforms.slice();\n  var subschemaConfig;\n\n  if (isSubschemaConfig(subschemaOrSubschemaConfig)) {\n    subschemaConfig = subschemaOrSubschemaConfig;\n    targetSchema = subschemaConfig.schema;\n    targetRootValue = rootValue != null ? rootValue : subschemaConfig.rootValue != null ? subschemaConfig.rootValue : info.rootValue;\n\n    if (subschemaConfig.transforms != null) {\n      requestTransforms = requestTransforms.concat(subschemaConfig.transforms);\n    }\n  } else {\n    targetSchema = subschemaOrSubschemaConfig;\n    targetRootValue = rootValue != null ? rootValue : info.rootValue;\n  }\n\n  var delegationTransforms = buildDelegationTransforms(subschemaOrSubschemaConfig, info, context, targetSchema, fieldName, args, returnType, requestTransforms.reverse(), skipTypeMerging);\n  var processedRequest = applyRequestTransforms(request, delegationTransforms);\n\n  if (!skipValidation) {\n    var errors = validate(targetSchema, processedRequest.document);\n\n    if (errors.length > 0) {\n      var combinedError = combineErrors(errors);\n      throw combinedError;\n    }\n  }\n\n  if (operation === 'query' || operation === 'mutation') {\n    var executor = createExecutor(targetSchema, targetRootValue, context, subschemaConfig);\n    var executionResult = executor({\n      document: processedRequest.document,\n      context: context,\n      variables: processedRequest.variables\n    });\n\n    if (executionResult instanceof Promise) {\n      return executionResult.then(function (originalResult) {\n        return applyResultTransforms(originalResult, delegationTransforms);\n      });\n    }\n\n    return applyResultTransforms(executionResult, delegationTransforms);\n  }\n\n  var subscriber = createSubscriber(targetSchema, targetRootValue, context, subschemaConfig);\n  return subscriber({\n    document: processedRequest.document,\n    context: context,\n    variables: processedRequest.variables\n  }).then(function (subscriptionResult) {\n    if (isAsyncIterable(subscriptionResult)) {\n      // \"subscribe\" to the subscription result and map the result through the transforms\n      return mapAsyncIterator(subscriptionResult, function (result) {\n        var _a;\n\n        var transformedResult = applyResultTransforms(result, delegationTransforms); // wrap with fieldName to return for an additional round of resolutioon\n        // with payload as rootValue\n\n        return _a = {}, _a[info.fieldName] = transformedResult, _a;\n      });\n    }\n\n    return applyResultTransforms(subscriptionResult, delegationTransforms);\n  });\n}\n\nfunction createExecutor(schema, rootValue, context, subschemaConfig) {\n  var fetcher;\n  var targetRootValue = rootValue;\n\n  if (subschemaConfig != null) {\n    if (subschemaConfig.dispatcher != null) {\n      var dynamicLinkOrFetcher = subschemaConfig.dispatcher(context);\n      fetcher = typeof dynamicLinkOrFetcher === 'function' ? dynamicLinkOrFetcher : linkToFetcher(dynamicLinkOrFetcher);\n    } else if (subschemaConfig.link != null) {\n      fetcher = linkToFetcher(subschemaConfig.link);\n    } else if (subschemaConfig.fetcher != null) {\n      fetcher = subschemaConfig.fetcher;\n    }\n\n    if (!fetcher && !rootValue && subschemaConfig.rootValue != null) {\n      targetRootValue = subschemaConfig.rootValue;\n    }\n  }\n\n  if (fetcher != null) {\n    return function (_a) {\n      var document = _a.document,\n          graphqlContext = _a.context,\n          variables = _a.variables;\n      return fetcher({\n        query: document,\n        variables: variables,\n        context: {\n          graphqlContext: graphqlContext\n        }\n      });\n    };\n  }\n\n  return function (_a) {\n    var document = _a.document,\n        graphqlContext = _a.context,\n        variables = _a.variables;\n    return execute$1({\n      schema: schema,\n      document: document,\n      rootValue: targetRootValue,\n      contextValue: graphqlContext,\n      variableValues: variables\n    });\n  };\n}\n\nfunction createSubscriber(schema, rootValue, context, subschemaConfig) {\n  var link;\n  var targetRootValue = rootValue;\n\n  if (subschemaConfig != null) {\n    if (subschemaConfig.dispatcher != null) {\n      link = subschemaConfig.dispatcher(context);\n    } else if (subschemaConfig.link != null) {\n      link = subschemaConfig.link;\n    }\n\n    if (!link && !rootValue && subschemaConfig.rootValue != null) {\n      targetRootValue = subschemaConfig.rootValue;\n    }\n  }\n\n  if (link != null) {\n    return function (_a) {\n      var document = _a.document,\n          graphqlContext = _a.context,\n          variables = _a.variables;\n      var operation = {\n        query: document,\n        variables: variables,\n        context: {\n          graphqlContext: graphqlContext\n        }\n      };\n      var observable = execute(link, operation);\n      return Promise.resolve(observableToAsyncIterable(observable));\n    };\n  }\n\n  return function (_a) {\n    var document = _a.document,\n        graphqlContext = _a.context,\n        variables = _a.variables;\n    return subscribe({\n      schema: schema,\n      document: document,\n      rootValue: targetRootValue,\n      contextValue: graphqlContext,\n      variableValues: variables\n    });\n  };\n} // @schemaDefinition: A GraphQL type schema in shorthand\n// @resolvers: Definitions for resolvers to be merged with schema\n\n\nvar SchemaError =\n/** @class */\nfunction (_super) {\n  __extends(SchemaError, _super);\n\n  function SchemaError(message) {\n    var _this = _super.call(this, message) || this;\n\n    _this.message = message;\n    Error.captureStackTrace(_this, _this.constructor);\n    return _this;\n  }\n\n  return SchemaError;\n}(Error); // If we have any union or interface types throw if no there is no resolveType or isTypeOf resolvers\n\n\nfunction checkForResolveTypeResolver(schema, requireResolversForResolveType) {\n  Object.keys(schema.getTypeMap()).map(function (typeName) {\n    return schema.getType(typeName);\n  }).forEach(function (type) {\n    if (!isAbstractType(type)) {\n      return;\n    }\n\n    if (!type.resolveType) {\n      if (!requireResolversForResolveType) {\n        return;\n      }\n\n      throw new SchemaError(\"Type \\\"\" + type.name + \"\\\" is missing a \\\"__resolveType\\\" resolver. Pass false into \" + '\"resolverValidationOptions.requireResolversForResolveType\" to disable this error.');\n    }\n  });\n}\n\nfunction extendResolversFromInterfaces(schema, resolvers) {\n  var typeNames = Object.keys(__assign(__assign({}, schema.getTypeMap()), resolvers));\n  var extendedResolvers = {};\n  typeNames.forEach(function (typeName) {\n    var typeResolvers = resolvers[typeName];\n    var type = schema.getType(typeName);\n\n    if (isObjectType(type) || graphqlVersion() >= 15 && isInterfaceType(type)) {\n      var interfaceResolvers = type.getInterfaces().map(function (iFace) {\n        return resolvers[iFace.name];\n      });\n      extendedResolvers[typeName] = Object.assign.apply(Object, __spreadArrays([{}], interfaceResolvers, [typeResolvers]));\n    } else if (typeResolvers != null) {\n      extendedResolvers[typeName] = typeResolvers;\n    }\n  });\n  return extendedResolvers;\n}\n\nfunction addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n  var options = isSchema(schemaOrOptions) ? {\n    schema: schemaOrOptions,\n    resolvers: legacyInputResolvers,\n    resolverValidationOptions: legacyInputValidationOptions\n  } : schemaOrOptions;\n  var schema = options.schema,\n      inputResolvers = options.resolvers,\n      defaultFieldResolver = options.defaultFieldResolver,\n      _a = options.resolverValidationOptions,\n      resolverValidationOptions = _a === void 0 ? {} : _a,\n      _b = options.inheritResolversFromInterfaces,\n      inheritResolversFromInterfaces = _b === void 0 ? false : _b;\n  var _c = resolverValidationOptions.allowResolversNotInSchema,\n      allowResolversNotInSchema = _c === void 0 ? false : _c,\n      requireResolversForResolveType = resolverValidationOptions.requireResolversForResolveType;\n  var resolvers = inheritResolversFromInterfaces ? extendResolversFromInterfaces(schema, inputResolvers) : inputResolvers;\n  var typeMap = schema.getTypeMap();\n  Object.keys(resolvers).forEach(function (typeName) {\n    var resolverValue = resolvers[typeName];\n\n    var resolverType = _typeof(resolverValue);\n\n    if (resolverType !== 'object' && resolverType !== 'function') {\n      throw new SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but has invalid value \\\"\" + resolverValue + \"\\\". A resolver's value must be of type object or function.\");\n    }\n\n    var type = schema.getType(typeName);\n\n    if (!type && typeName !== '__schema') {\n      if (allowResolversNotInSchema) {\n        return;\n      }\n\n      throw new SchemaError(\"\\\"\" + typeName + \"\\\" defined in resolvers, but not in schema\");\n    }\n\n    if (isScalarType(type)) {\n      // Support -- without recommending -- overriding default scalar types\n      Object.keys(resolverValue).forEach(function (fieldName) {\n        if (fieldName.startsWith('__')) {\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n        } else {\n          type[fieldName] = resolverValue[fieldName];\n        }\n      });\n    } else if (isEnumType(type)) {\n      // We've encountered an enum resolver that is being used to provide an\n      // internal enum value.\n      // Reference: https://www.apollographql.com/docs/graphql-tools/scalars.html#internal-values\n      Object.keys(resolverValue).forEach(function (fieldName) {\n        if (!type.getValue(fieldName)) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new SchemaError(typeName + \".\" + fieldName + \" was defined in resolvers, but enum is not in schema\");\n        }\n      });\n      var config = toConfig(type);\n      var values = type.getValues();\n      var newValues = keyValMap(values, function (value) {\n        return value.name;\n      }, function (value) {\n        var newValue = Object.keys(resolverValue).includes(value.name) ? resolverValue[value.name] : value.name;\n        return {\n          value: newValue,\n          deprecationReason: value.deprecationReason,\n          description: value.description,\n          astNode: value.astNode\n        };\n      }); // healSchema called later to update all fields to new type\n\n      typeMap[typeName] = new GraphQLEnumType(__assign(__assign({}, config), {\n        values: newValues\n      }));\n    } else if (isUnionType(type)) {\n      Object.keys(resolverValue).forEach(function (fieldName) {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n\n        if (allowResolversNotInSchema) {\n          return;\n        }\n\n        throw new SchemaError(typeName + \" was defined in resolvers, but it's not an object\");\n      });\n    } else if (isObjectType(type) || isInterfaceType(type)) {\n      Object.keys(resolverValue).forEach(function (fieldName) {\n        if (fieldName.startsWith('__')) {\n          // this is for isTypeOf and resolveType and all the other stuff.\n          type[fieldName.substring(2)] = resolverValue[fieldName];\n          return;\n        }\n\n        var fields = type.getFields();\n        var field = fields[fieldName];\n\n        if (field == null) {\n          if (allowResolversNotInSchema) {\n            return;\n          }\n\n          throw new SchemaError(typeName + \".\" + fieldName + \" defined in resolvers, but not in schema\");\n        }\n\n        var fieldResolve = resolverValue[fieldName];\n\n        if (typeof fieldResolve === 'function') {\n          // for convenience. Allows shorter syntax in resolver definition file\n          field.resolve = fieldResolve;\n        } else {\n          if (_typeof(fieldResolve) !== 'object') {\n            throw new SchemaError(\"Resolver \" + typeName + \".\" + fieldName + \" must be object or function\");\n          }\n\n          setFieldProperties(field, fieldResolve);\n        }\n      });\n    }\n  });\n  checkForResolveTypeResolver(schema, requireResolversForResolveType); // serialize all default values prior to healing fields with new scalar/enum types.\n\n  forEachDefaultValue(schema, serializeInputValue); // schema may have new scalar/enum types that require healing\n\n  healSchema(schema); // reparse all default values with new parsing functions.\n\n  forEachDefaultValue(schema, parseInputValue);\n\n  if (defaultFieldResolver != null) {\n    forEachField(schema, function (field) {\n      if (!field.resolve) {\n        field.resolve = defaultFieldResolver;\n      }\n    });\n  }\n\n  return schema;\n}\n\nfunction setFieldProperties(field, propertiesObj) {\n  Object.keys(propertiesObj).forEach(function (propertyName) {\n    field[propertyName] = propertiesObj[propertyName];\n  });\n} // wraps all resolvers of query, mutation or subscription fields\n// with the provided function to simulate a root schema level resolver\n\n\nfunction addSchemaLevelResolver(schema, fn) {\n  // TODO test that schema is a schema, fn is a function\n  var rootTypes = [schema.getQueryType(), schema.getMutationType(), schema.getSubscriptionType()].filter(function (x) {\n    return Boolean(x);\n  });\n  rootTypes.forEach(function (type) {\n    if (type != null) {\n      // XXX this should run at most once per request to simulate a true root resolver\n      // for graphql-js this is an approximation that works with queries but not mutations\n      var rootResolveFn_1 = runAtMostOncePerRequest(fn);\n      var fields_1 = type.getFields();\n      Object.keys(fields_1).forEach(function (fieldName) {\n        // XXX if the type is a subscription, a same query AST will be ran multiple times so we\n        // deactivate here the runOnce if it's a subscription. This may not be optimal though...\n        if (type === schema.getSubscriptionType()) {\n          fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, fn);\n        } else {\n          fields_1[fieldName].resolve = wrapResolver(fields_1[fieldName].resolve, rootResolveFn_1);\n        }\n      });\n    }\n  });\n} // XXX badly named function. this doesn't really wrap, it just chains resolvers...\n\n\nfunction wrapResolver(innerResolver, outerResolver) {\n  return function (obj, args, ctx, info) {\n    return Promise.resolve(outerResolver(obj, args, ctx, info)).then(function (root) {\n      if (innerResolver != null) {\n        return innerResolver(root, args, ctx, info);\n      }\n\n      return defaultFieldResolver(root, args, ctx, info);\n    });\n  };\n} // XXX this function only works for resolvers\n// XXX very hacky way to remember if the function\n// already ran for this request. This will only work\n// if people don't actually cache the operation.\n// if they do cache the operation, they will have to\n// manually remove the __runAtMostOnce before every request.\n\n\nfunction runAtMostOncePerRequest(fn) {\n  var value;\n  var randomNumber = Math.random();\n  return function (root, args, ctx, info) {\n    if (!info.operation['__runAtMostOnce']) {\n      info.operation['__runAtMostOnce'] = {};\n    }\n\n    if (!info.operation['__runAtMostOnce'][randomNumber]) {\n      info.operation['__runAtMostOnce'][randomNumber] = true;\n      value = fn(root, args, ctx, info);\n    }\n\n    return value;\n  };\n}\n\nfunction assertResolversPresent(schema, resolverValidationOptions) {\n  if (resolverValidationOptions === void 0) {\n    resolverValidationOptions = {};\n  }\n\n  var _a = resolverValidationOptions.requireResolversForArgs,\n      requireResolversForArgs = _a === void 0 ? false : _a,\n      _b = resolverValidationOptions.requireResolversForNonScalar,\n      requireResolversForNonScalar = _b === void 0 ? false : _b,\n      _c = resolverValidationOptions.requireResolversForAllFields,\n      requireResolversForAllFields = _c === void 0 ? false : _c;\n\n  if (requireResolversForAllFields && (requireResolversForArgs || requireResolversForNonScalar)) {\n    throw new TypeError('requireResolversForAllFields takes precedence over the more specific assertions. ' + 'Please configure either requireResolversForAllFields or requireResolversForArgs / ' + 'requireResolversForNonScalar, but not a combination of them.');\n  }\n\n  forEachField(schema, function (field, typeName, fieldName) {\n    // requires a resolver for *every* field.\n    if (requireResolversForAllFields) {\n      expectResolver(field, typeName, fieldName);\n    } // requires a resolver on every field that has arguments\n\n\n    if (requireResolversForArgs && field.args.length > 0) {\n      expectResolver(field, typeName, fieldName);\n    } // requires a resolver on every field that returns a non-scalar type\n\n\n    if (requireResolversForNonScalar && !isScalarType(getNamedType(field.type))) {\n      expectResolver(field, typeName, fieldName);\n    }\n  });\n}\n\nfunction expectResolver(field, typeName, fieldName) {\n  if (!field.resolve) {\n    // eslint-disable-next-line no-console\n    console.warn(\"Resolver missing for \\\"\" + typeName + \".\" + fieldName + \"\\\". To disable this warning check https://github.com/apollostack/graphql-tools/issues/131\");\n    return;\n  }\n\n  if (typeof field.resolve !== 'function') {\n    throw new SchemaError(\"Resolver \\\"\" + typeName + \".\" + fieldName + \"\\\" must be a function\");\n  }\n}\n\nfunction attachDirectiveResolvers(schema, directiveResolvers) {\n  if (_typeof(directiveResolvers) !== 'object') {\n    throw new Error(\"Expected directiveResolvers to be of type object, got \" + _typeof(directiveResolvers));\n  }\n\n  if (Array.isArray(directiveResolvers)) {\n    throw new Error('Expected directiveResolvers to be of type object, got Array');\n  }\n\n  var schemaDirectives = Object.create(null);\n  Object.keys(directiveResolvers).forEach(function (directiveName) {\n    schemaDirectives[directiveName] =\n    /** @class */\n    function (_super) {\n      __extends(class_1, _super);\n\n      function class_1() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      class_1.prototype.visitFieldDefinition = function (field) {\n        var resolver = directiveResolvers[directiveName];\n        var originalResolver = field.resolve != null ? field.resolve : defaultFieldResolver;\n        var directiveArgs = this.args;\n\n        field.resolve = function () {\n          var args = [];\n\n          for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n          }\n\n          var source = args[0]\n          /* original args */\n          ,\n              context = args[2],\n              info = args[3];\n          return resolver(function () {\n            return new Promise(function (resolve, reject) {\n              var result = originalResolver.apply(field, args);\n\n              if (result instanceof Error) {\n                reject(result);\n              }\n\n              resolve(result);\n            });\n          }, source, directiveArgs, context, info);\n        };\n      };\n\n      return class_1;\n    }(SchemaDirectiveVisitor);\n  });\n  SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n} // takes a GraphQL-JS schema and an object of connectors, then attaches\n// the connectors to the context by wrapping each query or mutation resolve\n// function with a function that attaches connectors if they don't exist.\n// attaches connectors only once to make sure they are singletons\n\n\nvar attachConnectorsToContext = deprecated({\n  version: '0.7.0',\n  url: 'https://github.com/apollostack/graphql-tools/issues/140'\n}, function (schema, connectors) {\n  if (!schema || !isSchema(schema)) {\n    throw new Error('schema must be an instance of GraphQLSchema. ' + 'This error could be caused by installing more than one version of GraphQL-JS');\n  }\n\n  if (_typeof(connectors) !== 'object') {\n    var connectorType = _typeof(connectors);\n\n    throw new Error(\"Expected connectors to be of type object, got \" + connectorType);\n  }\n\n  if (Object.keys(connectors).length === 0) {\n    throw new Error('Expected connectors to not be an empty object');\n  }\n\n  if (Array.isArray(connectors)) {\n    throw new Error('Expected connectors to be of type object, got Array');\n  }\n\n  if (schema['_apolloConnectorsAttached']) {\n    throw new Error('Connectors already attached to context, cannot attach more than once');\n  }\n\n  schema['_apolloConnectorsAttached'] = true;\n\n  var attachconnectorFn = function attachconnectorFn(root, _args, ctx) {\n    if (_typeof(ctx) !== 'object') {\n      // if in any way possible, we should throw an error when the attachconnectors\n      // function is called, not when a query is executed.\n      var contextType = _typeof(ctx);\n\n      throw new Error(\"Cannot attach connector because context is not an object: \" + contextType);\n    }\n\n    if (typeof ctx.connectors === 'undefined') {\n      ctx.connectors = {};\n    }\n\n    Object.keys(connectors).forEach(function (connectorName) {\n      var connector = connectors[connectorName];\n\n      if (connector.prototype != null) {\n        ctx.connectors[connectorName] = new connector(ctx);\n      } else {\n        throw new Error('Connector must be a function or an class');\n      }\n    });\n    return root;\n  };\n\n  addSchemaLevelResolver(schema, attachconnectorFn);\n});\n\nfunction extractExtensionDefinitions(ast) {\n  var extensionDefs = ast.definitions.filter(function (def) {\n    return def.kind === Kind.OBJECT_TYPE_EXTENSION || graphqlVersion() >= 13 && def.kind === Kind.INTERFACE_TYPE_EXTENSION || def.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION || def.kind === Kind.UNION_TYPE_EXTENSION || def.kind === Kind.ENUM_TYPE_EXTENSION || def.kind === Kind.SCALAR_TYPE_EXTENSION || def.kind === Kind.SCHEMA_EXTENSION;\n  });\n  return __assign(__assign({}, ast), {\n    definitions: extensionDefs\n  });\n}\n\nfunction filterExtensionDefinitions(ast) {\n  var extensionDefs = ast.definitions.filter(function (def) {\n    return def.kind !== Kind.OBJECT_TYPE_EXTENSION && def.kind !== Kind.INTERFACE_TYPE_EXTENSION && def.kind !== Kind.INPUT_OBJECT_TYPE_EXTENSION && def.kind !== Kind.UNION_TYPE_EXTENSION && def.kind !== Kind.ENUM_TYPE_EXTENSION && def.kind !== Kind.SCALAR_TYPE_EXTENSION && def.kind !== Kind.SCHEMA_EXTENSION;\n  });\n  return __assign(__assign({}, ast), {\n    definitions: extensionDefs\n  });\n}\n\nfunction concatenateTypeDefs(typeDefinitionsAry, calledFunctionRefs) {\n  if (calledFunctionRefs === void 0) {\n    calledFunctionRefs = [];\n  }\n\n  var resolvedTypeDefinitions = [];\n  typeDefinitionsAry.forEach(function (typeDef) {\n    if (typeof typeDef === 'function') {\n      if (calledFunctionRefs.indexOf(typeDef) === -1) {\n        calledFunctionRefs.push(typeDef);\n        resolvedTypeDefinitions = resolvedTypeDefinitions.concat(concatenateTypeDefs(typeDef(), calledFunctionRefs));\n      }\n    } else if (typeof typeDef === 'string') {\n      resolvedTypeDefinitions.push(typeDef.trim());\n    } else if (typeDef.kind !== undefined) {\n      resolvedTypeDefinitions.push(print(typeDef).trim());\n    } else {\n      var type = _typeof(typeDef);\n\n      throw new SchemaError(\"typeDef array must contain only strings and functions, got \" + type);\n    }\n  });\n  return uniq(resolvedTypeDefinitions.map(function (x) {\n    return x.trim();\n  })).join('\\n');\n}\n\nfunction uniq(array) {\n  return array.reduce(function (accumulator, currentValue) {\n    return accumulator.indexOf(currentValue) === -1 ? __spreadArrays(accumulator, [currentValue]) : accumulator;\n  }, []);\n}\n\nfunction buildSchemaFromTypeDefinitions(typeDefinitions, parseOptions) {\n  // TODO: accept only array here, otherwise interfaces get confusing.\n  var myDefinitions = typeDefinitions;\n  var astDocument;\n\n  if (isDocumentNode(typeDefinitions)) {\n    astDocument = typeDefinitions;\n  } else if (typeof myDefinitions !== 'string') {\n    if (!Array.isArray(myDefinitions)) {\n      var type = _typeof(myDefinitions);\n\n      throw new SchemaError(\"typeDefs must be a string, array or schema AST, got \" + type);\n    }\n\n    myDefinitions = concatenateTypeDefs(myDefinitions);\n  }\n\n  if (typeof myDefinitions === 'string') {\n    astDocument = parse(myDefinitions, parseOptions);\n  }\n\n  var typesAst = filterExtensionDefinitions(astDocument);\n  var backcompatOptions = {\n    commentDescriptions: true\n  };\n  var schema = buildASTSchema(typesAst, backcompatOptions);\n  var extensionsAst = extractExtensionDefinitions(astDocument);\n\n  if (extensionsAst.definitions.length > 0) {\n    schema = extendSchema$1(schema, extensionsAst, backcompatOptions);\n  }\n\n  return schema;\n}\n\nfunction isDocumentNode(typeDefinitions) {\n  return typeDefinitions.kind !== undefined;\n}\n\nfunction chainResolvers(resolvers) {\n  return function (root, args, ctx, info) {\n    return resolvers.reduce(function (prev, curResolver) {\n      if (curResolver != null) {\n        return curResolver(prev, args, ctx, info);\n      }\n\n      return defaultFieldResolver(prev, args, ctx, info);\n    }, root);\n  };\n}\n/*\r\n * fn: The function to decorate with the logger\r\n * logger: an object instance of type Logger\r\n * hint: an optional hint to add to the error's message\r\n */\n\n\nfunction decorateWithLogger(fn, logger, hint) {\n  var resolver = fn != null ? fn : defaultFieldResolver;\n\n  var logError = function logError(e) {\n    // TODO: clone the error properly\n    var newE = new Error();\n    newE.stack = e.stack;\n    /* istanbul ignore else: always get the hint from addErrorLoggingToSchema */\n\n    if (hint) {\n      newE['originalMessage'] = e.message;\n      newE['message'] = \"Error in resolver \" + hint + \"\\n\" + e.message;\n    }\n\n    logger.log(newE);\n  };\n\n  return function (root, args, ctx, info) {\n    try {\n      var result = resolver(root, args, ctx, info); // If the resolver returns a Promise log any Promise rejects.\n\n      if (result && typeof result.then === 'function' && typeof result[\"catch\"] === 'function') {\n        result[\"catch\"](function (reason) {\n          // make sure that it's an error we're logging.\n          var error = reason instanceof Error ? reason : new Error(reason);\n          logError(error); // We don't want to leave an unhandled exception so pass on error.\n\n          return reason;\n        });\n      }\n\n      return result;\n    } catch (e) {\n      logError(e); // we want to pass on the error, just in case.\n\n      throw e;\n    }\n  };\n}\n\nfunction makeExecutableSchema(_a) {\n  var typeDefs = _a.typeDefs,\n      _b = _a.resolvers,\n      resolvers = _b === void 0 ? {} : _b,\n      connectors = _a.connectors,\n      logger = _a.logger,\n      _c = _a.allowUndefinedInResolve,\n      allowUndefinedInResolve = _c === void 0 ? true : _c,\n      _d = _a.resolverValidationOptions,\n      resolverValidationOptions = _d === void 0 ? {} : _d,\n      directiveResolvers = _a.directiveResolvers,\n      schemaDirectives = _a.schemaDirectives,\n      _e = _a.parseOptions,\n      parseOptions = _e === void 0 ? {} : _e,\n      _f = _a.inheritResolversFromInterfaces,\n      inheritResolversFromInterfaces = _f === void 0 ? false : _f; // Validate and clean up arguments\n\n  if (_typeof(resolverValidationOptions) !== 'object') {\n    throw new SchemaError('Expected `resolverValidationOptions` to be an object');\n  }\n\n  if (!typeDefs) {\n    throw new SchemaError('Must provide typeDefs');\n  } // We allow passing in an array of resolver maps, in which case we merge them\n\n\n  var resolverMap = Array.isArray(resolvers) ? resolvers.filter(function (resolverObj) {\n    return _typeof(resolverObj) === 'object';\n  }).reduce(mergeDeep, {}) : resolvers; // Arguments are now validated and cleaned up\n\n  var schema = buildSchemaFromTypeDefinitions(typeDefs, parseOptions);\n  addResolversToSchema({\n    schema: schema,\n    resolvers: resolverMap,\n    resolverValidationOptions: resolverValidationOptions,\n    inheritResolversFromInterfaces: inheritResolversFromInterfaces\n  });\n  assertResolversPresent(schema, resolverValidationOptions);\n\n  if (!allowUndefinedInResolve) {\n    addCatchUndefinedToSchema(schema);\n  }\n\n  if (logger != null) {\n    addErrorLoggingToSchema(schema, logger);\n  }\n\n  if (typeof resolvers['__schema'] === 'function') {\n    // TODO a bit of a hack now, better rewrite generateSchema to attach it there.\n    // not doing that now, because I'd have to rewrite a lot of tests.\n    addSchemaLevelResolver(schema, resolvers['__schema']);\n  }\n\n  if (connectors != null) {\n    // connectors are optional, at least for now. That means you can just import them in the resolve\n    // function if you want.\n    attachConnectorsToContext(schema, connectors);\n  }\n\n  if (directiveResolvers != null) {\n    attachDirectiveResolvers(schema, directiveResolvers);\n  }\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(schema, schemaDirectives);\n  }\n\n  return schema;\n}\n\nfunction decorateToCatchUndefined(fn, hint) {\n  var resolve = fn == null ? defaultFieldResolver : fn;\n  return function (root, args, ctx, info) {\n    var result = resolve(root, args, ctx, info);\n\n    if (typeof result === 'undefined') {\n      throw new Error(\"Resolver for \\\"\" + hint + \"\\\" returned undefined\");\n    }\n\n    return result;\n  };\n}\n\nfunction addCatchUndefinedToSchema(schema) {\n  forEachField(schema, function (field, typeName, fieldName) {\n    var errorHint = typeName + \".\" + fieldName;\n    field.resolve = decorateToCatchUndefined(field.resolve, errorHint);\n  });\n}\n\nfunction addErrorLoggingToSchema(schema, logger) {\n  if (!logger) {\n    throw new Error('Must provide a logger');\n  }\n\n  if (typeof logger.log !== 'function') {\n    throw new Error('Logger.log must be a function');\n  }\n\n  forEachField(schema, function (field, typeName, fieldName) {\n    var errorHint = typeName + \".\" + fieldName;\n    field.resolve = decorateWithLogger(field.resolve, logger, errorHint);\n  });\n} // These functions are preserved for backwards compatibility.\n// They are not simply rexported with new (old) names so as to allow\n// typedoc to annotate them.\n\n\nfunction addResolveFunctionsToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions) {\n  return addResolversToSchema(schemaOrOptions, legacyInputResolvers, legacyInputValidationOptions);\n}\n\nfunction addSchemaLevelResolveFunction(schema, fn) {\n  addSchemaLevelResolver(schema, fn);\n}\n\nfunction assertResolveFunctionsPresent(schema, resolverValidationOptions) {\n  if (resolverValidationOptions === void 0) {\n    resolverValidationOptions = {};\n  }\n\n  assertResolversPresent(schema, resolverValidationOptions);\n}\n\nfunction getFinalPromise(object) {\n  return Promise.resolve(object).then(function (resolvedObject) {\n    if (resolvedObject == null) {\n      return resolvedObject;\n    }\n\n    if (Array.isArray(resolvedObject)) {\n      return Promise.all(resolvedObject.map(function (o) {\n        return getFinalPromise(o);\n      }));\n    } else if (_typeof(resolvedObject) === 'object') {\n      var keys_1 = Object.keys(resolvedObject);\n      return Promise.all(keys_1.map(function (key) {\n        return getFinalPromise(resolvedObject[key]);\n      })).then(function (awaitedValues) {\n        for (var i = 0; i < keys_1.length; i++) {\n          resolvedObject[keys_1[i]] = awaitedValues[i];\n        }\n\n        return resolvedObject;\n      });\n    }\n\n    return resolvedObject;\n  });\n}\n\nvar AwaitVariablesLink =\n/** @class */\nfunction (_super) {\n  __extends(AwaitVariablesLink, _super);\n\n  function AwaitVariablesLink() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  AwaitVariablesLink.prototype.request = function (operation, forward) {\n    return new Observable(function (observer) {\n      var subscription;\n      getFinalPromise(operation.variables).then(function (resolvedVariables) {\n        operation.variables = resolvedVariables;\n        subscription = forward(operation).subscribe({\n          next: observer.next.bind(observer),\n          error: observer.error.bind(observer),\n          complete: observer.complete.bind(observer)\n        });\n      })[\"catch\"](observer.error.bind(observer));\n      return function () {\n        if (subscription != null) {\n          subscription.unsubscribe();\n        }\n      };\n    });\n  };\n\n  return AwaitVariablesLink;\n}(ApolloLink);\n/* eslint-disable import/no-nodejs-modules */\n\n\nvar FormDataWithStreamSupport =\n/** @class */\nfunction (_super) {\n  __extends(FormDataWithStreamSupport, _super);\n\n  function FormDataWithStreamSupport(options) {\n    var _this = _super.call(this, options) || this;\n\n    _this.hasUnknowableLength = false;\n    return _this;\n  }\n\n  FormDataWithStreamSupport.prototype.append = function (key, value, optionsOrFilename) {\n    if (optionsOrFilename === void 0) {\n      optionsOrFilename = {};\n    } // allow filename as single option\n\n\n    var options = typeof optionsOrFilename === 'string' ? {\n      filename: optionsOrFilename\n    } : optionsOrFilename; // empty or either doesn't have path or not an http response\n\n    if (!options.knownLength && !Buffer.isBuffer(value) && typeof value !== 'string' && !value.path && !(value.readable && hasOwnProperty(value, 'httpVersion'))) {\n      this.hasUnknowableLength = true;\n    }\n\n    _super.prototype.append.call(this, key, value, options);\n  };\n\n  FormDataWithStreamSupport.prototype.getLength = function (callback) {\n    if (this.hasUnknowableLength) {\n      return null;\n    }\n\n    return _super.prototype.getLength.call(this, callback);\n  };\n\n  FormDataWithStreamSupport.prototype.getLengthSync = function () {\n    if (this.hasUnknowableLength) {\n      return null;\n    } // eslint-disable-next-line no-sync\n\n\n    return _super.prototype.getLengthSync.call(this);\n  };\n\n  return FormDataWithStreamSupport;\n}(FormData);\n\nvar createServerHttpLink = function createServerHttpLink(options) {\n  return concat(new AwaitVariablesLink(), createUploadLink(__assign(__assign({}, options), {\n    fetch: fetch,\n    FormData: FormDataWithStreamSupport,\n    isExtractableFile: function isExtractableFile(value) {\n      return _isExtractableFile(value) || (value === null || value === void 0 ? void 0 : value.createReadStream);\n    },\n    formDataAppendFile: function formDataAppendFile(form, index, file) {\n      if (file.createReadStream != null) {\n        form.append(index, file.createReadStream(), {\n          filename: file.filename,\n          contentType: file.mimetype\n        });\n      } else {\n        _formDataAppendFile(form, index, file);\n      }\n    }\n  })));\n};\n/**\r\n * This function wraps addMocksToSchema for more convenience\r\n */\n\n\nfunction mockServer(schema, mocks, preserveResolvers) {\n  if (preserveResolvers === void 0) {\n    preserveResolvers = false;\n  }\n\n  var mySchema;\n\n  if (!isSchema(schema)) {\n    // TODO: provide useful error messages here if this fails\n    mySchema = buildSchemaFromTypeDefinitions(schema);\n  } else {\n    mySchema = schema;\n  }\n\n  addMocksToSchema({\n    schema: mySchema,\n    mocks: mocks,\n    preserveResolvers: preserveResolvers\n  });\n  return {\n    query: function query(_query, vars) {\n      return graphql(mySchema, _query, {}, {}, vars);\n    }\n  };\n}\n\nvar defaultMockMap = new Map();\ndefaultMockMap.set('Int', function () {\n  return Math.round(Math.random() * 200) - 100;\n});\ndefaultMockMap.set('Float', function () {\n  return Math.random() * 200 - 100;\n});\ndefaultMockMap.set('String', function () {\n  return 'Hello World';\n});\ndefaultMockMap.set('Boolean', function () {\n  return Math.random() > 0.5;\n});\ndefaultMockMap.set('ID', function () {\n  return v4();\n}); // TODO allow providing a seed such that lengths of list could be deterministic\n// this could be done by using casual to get a random list length if the casual\n// object is global.\n\nfunction addMocksToSchema(_a) {\n  var schema = _a.schema,\n      _b = _a.mocks,\n      mocks = _b === void 0 ? {} : _b,\n      _c = _a.preserveResolvers,\n      preserveResolvers = _c === void 0 ? false : _c;\n\n  if (!schema) {\n    throw new Error('Must provide schema to mock');\n  }\n\n  if (!isSchema(schema)) {\n    throw new Error('Value at \"schema\" must be of type GraphQLSchema');\n  }\n\n  if (!isObject$1(mocks)) {\n    throw new Error('mocks must be of type Object');\n  } // use Map internally, because that API is nicer.\n\n\n  var mockFunctionMap = new Map();\n  Object.keys(mocks).forEach(function (typeName) {\n    mockFunctionMap.set(typeName, mocks[typeName]);\n  });\n  mockFunctionMap.forEach(function (mockFunction, mockTypeName) {\n    if (typeof mockFunction !== 'function') {\n      throw new Error(\"mockFunctionMap[\" + mockTypeName + \"] must be a function\");\n    }\n  });\n\n  var mockType = function mockType(type, _typeName, fieldName) {\n    // order of precendence for mocking:\n    // 1. if the object passed in already has fieldName, just use that\n    // --> if it's a function, that becomes your resolver\n    // --> if it's a value, the mock resolver will return that\n    // 2. if the nullableType is a list, recurse\n    // 2. if there's a mock defined for this typeName, that will be used\n    // 3. if there's no mock defined, use the default mocks for this type\n    return function (root, args, context, info) {\n      // nullability doesn't matter for the purpose of mocking.\n      var fieldType = getNullableType(type);\n      var namedFieldType = getNamedType(fieldType);\n\n      if (fieldName && root && typeof root[fieldName] !== 'undefined') {\n        var result = void 0; // if we're here, the field is already defined\n\n        if (typeof root[fieldName] === 'function') {\n          result = root[fieldName](root, args, context, info);\n\n          if (result instanceof MockList) {\n            result = result.mock(root, args, context, info, fieldType, mockType);\n          }\n        } else {\n          result = root[fieldName];\n        } // Now we merge the result with the default mock for this type.\n        // This allows overriding defaults while writing very little code.\n\n\n        if (mockFunctionMap.has(namedFieldType.name)) {\n          var mock = mockFunctionMap.get(namedFieldType.name);\n          result = mergeMocks(mock.bind(null, root, args, context, info), result);\n        }\n\n        return result;\n      }\n\n      if (isListType(fieldType)) {\n        return [mockType(fieldType.ofType)(root, args, context, info), mockType(fieldType.ofType)(root, args, context, info)];\n      }\n\n      if (mockFunctionMap.has(fieldType.name) && !isAbstractType(fieldType)) {\n        // the object passed doesn't have this field, so we apply the default mock\n        var mock = mockFunctionMap.get(fieldType.name);\n        return mock(root, args, context, info);\n      }\n\n      if (isObjectType(fieldType)) {\n        // objects don't return actual data, we only need to mock scalars!\n        return {};\n      } // if a mock function is provided for unionType or interfaceType, execute it to resolve the concrete type\n      // otherwise randomly pick a type from all implementation types\n\n\n      if (isAbstractType(fieldType)) {\n        var implementationType = void 0;\n\n        if (mockFunctionMap.has(fieldType.name)) {\n          var mock = mockFunctionMap.get(fieldType.name);\n          var interfaceMockObj = mock(root, args, context, info);\n\n          if (!interfaceMockObj || !interfaceMockObj.__typename) {\n            return Error(\"Please return a __typename in \\\"\" + fieldType.name + \"\\\"\");\n          }\n\n          implementationType = schema.getType(interfaceMockObj.__typename);\n        } else {\n          var possibleTypes = schema.getPossibleTypes(fieldType);\n          implementationType = getRandomElement(possibleTypes);\n        }\n\n        return __assign({\n          __typename: implementationType\n        }, mockType(implementationType)(root, args, context, info));\n      }\n\n      if (isEnumType(fieldType)) {\n        return getRandomElement(fieldType.getValues()).value;\n      }\n\n      if (defaultMockMap.has(fieldType.name)) {\n        var defaultMock = defaultMockMap.get(fieldType.name);\n        return defaultMock(root, args, context, info);\n      } // if we get to here, we don't have a value, and we don't have a mock for this type,\n      // we could return undefined, but that would be hard to debug, so we throw instead.\n      // however, we returning it instead of throwing it, so preserveResolvers can handle the failures.\n\n\n      return Error(\"No mock defined for type \\\"\" + fieldType.name + \"\\\"\");\n    };\n  };\n\n  forEachField(schema, function (field, typeName, fieldName) {\n    assignResolveType(field.type, preserveResolvers);\n    var mockResolver = mockType(field.type, typeName, fieldName); // we have to handle the root mutation and root query types differently,\n    // because no resolver is called at the root.\n\n    var queryType = schema.getQueryType();\n    var isOnQueryType = queryType != null && queryType.name === typeName;\n    var mutationType = schema.getMutationType();\n    var isOnMutationType = mutationType != null && mutationType.name === typeName;\n\n    if (isOnQueryType || isOnMutationType) {\n      if (mockFunctionMap.has(typeName)) {\n        var rootMock_1 = mockFunctionMap.get(typeName); // XXX: BUG in here, need to provide proper signature for rootMock.\n\n        if (typeof rootMock_1(undefined, {}, {}, {})[fieldName] === 'function') {\n          mockResolver = function mockResolver(root, args, context, info) {\n            var updatedRoot = root !== null && root !== void 0 ? root : {}; // TODO: should we clone instead?\n\n            updatedRoot[fieldName] = rootMock_1(root, args, context, info)[fieldName]; // XXX this is a bit of a hack to still use mockType, which\n            // lets you mock lists etc. as well\n            // otherwise we could just set field.resolve to rootMock()[fieldName]\n            // it's like pretending there was a resolver that ran before\n            // the root resolver.\n\n            return mockType(field.type, typeName, fieldName)(updatedRoot, args, context, info);\n          };\n        }\n      }\n    }\n\n    if (!preserveResolvers || !field.resolve) {\n      field.resolve = mockResolver;\n    } else {\n      var oldResolver_1 = field.resolve;\n\n      field.resolve = function (rootObject, args, context, info) {\n        return Promise.all([mockResolver(rootObject, args, context, info), oldResolver_1(rootObject, args, context, info)]).then(function (values) {\n          var mockedValue = values[0],\n              resolvedValue = values[1]; // In case we couldn't mock\n\n          if (mockedValue instanceof Error) {\n            // only if value was not resolved, populate the error.\n            if (undefined === resolvedValue) {\n              throw mockedValue;\n            }\n\n            return resolvedValue;\n          }\n\n          if (resolvedValue instanceof Date && mockedValue instanceof Date) {\n            return undefined !== resolvedValue ? resolvedValue : mockedValue;\n          }\n\n          if (isObject$1(mockedValue) && isObject$1(resolvedValue)) {\n            // Object.assign() won't do here, as we need to all properties, including\n            // the non-enumerable ones and defined using Object.defineProperty\n            var emptyObject = Object.create(Object.getPrototypeOf(resolvedValue));\n            return copyOwnProps(emptyObject, resolvedValue, mockedValue);\n          }\n\n          return undefined !== resolvedValue ? resolvedValue : mockedValue;\n        });\n      };\n    }\n  });\n}\n\nfunction isObject$1(thing) {\n  return thing === Object(thing) && !Array.isArray(thing);\n} // returns a random element from that ary\n\n\nfunction getRandomElement(ary) {\n  var sample = Math.floor(Math.random() * ary.length);\n  return ary[sample];\n}\n\nfunction mergeObjects(a, b) {\n  return Object.assign(a, b);\n}\n\nfunction copyOwnPropsIfNotPresent(target, source) {\n  Object.getOwnPropertyNames(source).forEach(function (prop) {\n    if (!Object.getOwnPropertyDescriptor(target, prop)) {\n      var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);\n      Object.defineProperty(target, prop, propertyDescriptor == null ? {} : propertyDescriptor);\n    }\n  });\n}\n\nfunction copyOwnProps(target) {\n  var sources = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    sources[_i - 1] = arguments[_i];\n  }\n\n  sources.forEach(function (source) {\n    var chain = source;\n\n    while (chain != null) {\n      copyOwnPropsIfNotPresent(target, chain);\n      chain = Object.getPrototypeOf(chain);\n    }\n  });\n  return target;\n} // takes either an object or a (possibly nested) array\n// and completes the customMock object with any fields\n// defined on genericMock\n// only merges objects or arrays. Scalars are returned as is\n\n\nfunction mergeMocks(genericMockFunction, customMock) {\n  if (Array.isArray(customMock)) {\n    return customMock.map(function (el) {\n      return mergeMocks(genericMockFunction, el);\n    });\n  }\n\n  if (isObject$1(customMock)) {\n    return mergeObjects(genericMockFunction(), customMock);\n  }\n\n  return customMock;\n}\n\nfunction getResolveType(namedFieldType) {\n  if (isAbstractType(namedFieldType)) {\n    return namedFieldType.resolveType;\n  }\n}\n\nfunction assignResolveType(type, preserveResolvers) {\n  var fieldType = getNullableType(type);\n  var namedFieldType = getNamedType(fieldType);\n  var oldResolveType = getResolveType(namedFieldType);\n\n  if (preserveResolvers && oldResolveType != null && oldResolveType.length) {\n    return;\n  }\n\n  if (isInterfaceType(namedFieldType) || isUnionType(namedFieldType)) {\n    // the default `resolveType` always returns null. We add a fallback\n    // resolution that works with how unions and interface are mocked\n    namedFieldType.resolveType = function (data, _context, info) {\n      return info.schema.getType(data.__typename);\n    };\n  }\n}\n\nvar MockList =\n/** @class */\nfunction () {\n  // wrappedFunction can return another MockList or a value\n  function MockList(len, wrappedFunction) {\n    this.len = len;\n\n    if (typeof wrappedFunction !== 'undefined') {\n      if (typeof wrappedFunction !== 'function') {\n        throw new Error('Second argument to MockList must be a function or undefined');\n      }\n\n      this.wrappedFunction = wrappedFunction;\n    }\n  }\n\n  MockList.prototype.mock = function (root, args, context, info, fieldType, mockTypeFunc) {\n    var arr;\n\n    if (Array.isArray(this.len)) {\n      arr = new Array(this.randint(this.len[0], this.len[1]));\n    } else {\n      arr = new Array(this.len);\n    }\n\n    for (var i = 0; i < arr.length; i++) {\n      if (typeof this.wrappedFunction === 'function') {\n        var res = this.wrappedFunction(root, args, context, info);\n\n        if (res instanceof MockList) {\n          var nullableType = getNullableType(fieldType.ofType);\n          arr[i] = res.mock(root, args, context, info, nullableType, mockTypeFunc);\n        } else {\n          arr[i] = res;\n        }\n      } else {\n        arr[i] = mockTypeFunc(fieldType.ofType)(root, args, context, info);\n      }\n    }\n\n    return arr;\n  };\n\n  MockList.prototype.randint = function (low, high) {\n    return Math.floor(Math.random() * (high - low + 1) + low);\n  };\n\n  return MockList;\n}(); // retain addMockFunctionsToSchema for backwards compatibility\n\n\nfunction addMockFunctionsToSchema(_a) {\n  var schema = _a.schema,\n      _b = _a.mocks,\n      mocks = _b === void 0 ? {} : _b,\n      _c = _a.preserveResolvers,\n      preserveResolvers = _c === void 0 ? false : _c;\n  addMocksToSchema({\n    schema: schema,\n    mocks: mocks,\n    preserveResolvers: preserveResolvers\n  });\n}\n\nvar GraphQLUpload = new GraphQLScalarType({\n  name: 'Upload',\n  description: 'The `Upload` scalar type represents a file upload.',\n  parseValue: function parseValue(value) {\n    if (value != null && value.promise instanceof Promise) {\n      // graphql-upload v10\n      return value.promise;\n    } else if (value instanceof Promise) {\n      // graphql-upload v9\n      return value;\n    }\n\n    throw new GraphQLError('Upload value invalid.');\n  },\n  // serialization requires to support schema stitching\n  serialize: function serialize(value) {\n    return value;\n  },\n  parseLiteral: function parseLiteral(ast) {\n    throw new GraphQLError('Upload literal unsupported.', ast);\n  }\n});\nvar parsedIntrospectionQuery = parse(getIntrospectionQuery());\n\nfunction introspectSchema(linkOrFetcher, linkContext) {\n  var fetcher = typeof linkOrFetcher === 'function' ? linkOrFetcher : linkToFetcher(linkOrFetcher);\n  return fetcher({\n    query: parsedIntrospectionQuery,\n    context: linkContext\n  }).then(function (introspectionResult) {\n    if (Array.isArray(introspectionResult.errors) && introspectionResult.errors.length || !introspectionResult.data.__schema) {\n      if (Array.isArray(introspectionResult.errors)) {\n        var combinedError = combineErrors(introspectionResult.errors);\n        throw combinedError;\n      } else {\n        throw new Error('Could not obtain introspection result, received: ' + JSON.stringify(introspectionResult));\n      }\n    } else {\n      var schema = buildClientSchema(introspectionResult.data);\n      return schema;\n    }\n  });\n}\n/**\r\n * Resolver that knows how to:\r\n * a) handle aliases for proxied schemas\r\n * b) handle errors from proxied schemas\r\n * c) handle external to internal enum coversion\r\n */\n\n\nfunction defaultMergedResolver(parent, args, context, info) {\n  if (!parent) {\n    return null;\n  }\n\n  var responseKey = getResponseKeyFromInfo(info);\n  var errors = getErrors(parent, responseKey); // check to see if parent is not a proxied result, i.e. if parent resolver was manually overwritten\n  // See https://github.com/apollographql/graphql-tools/issues/967\n\n  if (!errors) {\n    return defaultFieldResolver(parent, args, context, info);\n  }\n\n  var result = parent[responseKey];\n  var subschema = getSubschema(parent, responseKey);\n  return handleResult(result, errors, subschema, context, info);\n}\n\nfunction makeMergedType(type) {\n  if (isObjectType(type)) {\n    type.isTypeOf = undefined;\n    var fieldMap_1 = type.getFields();\n    Object.keys(fieldMap_1).forEach(function (fieldName) {\n      fieldMap_1[fieldName].resolve = defaultMergedResolver;\n      fieldMap_1[fieldName].subscribe = null;\n    });\n  } else if (isAbstractType(type)) {\n    type.resolveType = function (parent) {\n      return resolveFromParentTypename(parent);\n    };\n  }\n}\n\nfunction generateProxyingResolvers(_a) {\n  var subschemaConfig = _a.subschemaConfig,\n      transforms = _a.transforms;\n  var targetSchema = subschemaConfig.schema;\n  var operationTypes = {\n    query: targetSchema.getQueryType(),\n    mutation: targetSchema.getMutationType(),\n    subscription: targetSchema.getSubscriptionType()\n  };\n  var createProxyingResolver = subschemaConfig.createProxyingResolver != null ? subschemaConfig.createProxyingResolver : defaultCreateProxyingResolver;\n  var resolvers = {};\n  Object.keys(operationTypes).forEach(function (operation) {\n    var resolveField = operation === 'subscription' ? 'subscribe' : 'resolve';\n    var rootType = operationTypes[operation];\n\n    if (rootType != null) {\n      var typeName_1 = rootType.name;\n      var fields = rootType.getFields();\n      resolvers[typeName_1] = {};\n      Object.keys(fields).forEach(function (fieldName) {\n        var _a;\n\n        var proxyingResolver = createProxyingResolver(subschemaConfig, transforms, operation, fieldName);\n        var finalResolver = createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver);\n        resolvers[typeName_1][fieldName] = (_a = {}, _a[resolveField] = finalResolver, _a);\n      });\n    }\n  });\n  return resolvers;\n}\n\nfunction createPossiblyNestedProxyingResolver(subschemaConfig, proxyingResolver) {\n  return function (parent, args, context, info) {\n    if (parent != null) {\n      var responseKey = getResponseKeyFromInfo(info);\n      var errors = getErrors(parent, responseKey); // Check to see if the parent contains a proxied result\n\n      if (errors != null) {\n        var subschema = getSubschema(parent, responseKey); // If there is a proxied result from this subschema, return it\n        // This can happen even for a root field when the root type ia\n        // also nested as a field within a different type.\n\n        if (subschemaConfig === subschema) {\n          return handleResult(parent[responseKey], errors, subschema, context, info);\n        }\n      }\n    }\n\n    return proxyingResolver(parent, args, context, info);\n  };\n}\n\nfunction defaultCreateProxyingResolver(schema, transforms) {\n  return function (_parent, _args, context, info) {\n    return _delegateToSchema({\n      schema: schema,\n      context: context,\n      info: info,\n      transforms: transforms\n    });\n  };\n}\n\nfunction stripResolvers(schema) {\n  var typeMap = schema.getTypeMap();\n  Object.keys(typeMap).forEach(function (typeName) {\n    if (!typeName.startsWith('__')) {\n      makeMergedType(typeMap[typeName]);\n    }\n  });\n}\n\nfunction wrapSchema(subschemaOrSubschemaConfig, transforms) {\n  var subschemaConfig = isSubschemaConfig(subschemaOrSubschemaConfig) ? subschemaOrSubschemaConfig : {\n    schema: subschemaOrSubschemaConfig\n  };\n  var schema = cloneSchema(subschemaConfig.schema);\n  stripResolvers(schema);\n  var resolvers = generateProxyingResolvers({\n    subschemaConfig: subschemaConfig,\n    transforms: transforms\n  });\n  addResolversToSchema({\n    schema: schema,\n    resolvers: resolvers\n  });\n  var schemaTransforms = [];\n\n  if (subschemaConfig.transforms != null) {\n    schemaTransforms = schemaTransforms.concat(subschemaConfig.transforms);\n  }\n\n  if (transforms != null) {\n    schemaTransforms = schemaTransforms.concat(transforms);\n  }\n\n  return applySchemaTransforms(schema, schemaTransforms);\n}\n\nvar backcompatOptions = {\n  commentDescriptions: true\n};\n\nfunction typeFromAST(node) {\n  switch (node.kind) {\n    case Kind.OBJECT_TYPE_DEFINITION:\n      return makeObjectType(node);\n\n    case Kind.INTERFACE_TYPE_DEFINITION:\n      return makeInterfaceType(node);\n\n    case Kind.ENUM_TYPE_DEFINITION:\n      return makeEnumType(node);\n\n    case Kind.UNION_TYPE_DEFINITION:\n      return makeUnionType(node);\n\n    case Kind.SCALAR_TYPE_DEFINITION:\n      return makeScalarType(node);\n\n    case Kind.INPUT_OBJECT_TYPE_DEFINITION:\n      return makeInputObjectType(node);\n\n    case Kind.DIRECTIVE_DEFINITION:\n      return makeDirective(node);\n\n    default:\n      return null;\n  }\n}\n\nfunction makeObjectType(node) {\n  var config = {\n    name: node.name.value,\n    fields: function fields() {\n      return makeFields(node.fields);\n    },\n    interfaces: function interfaces() {\n      return node.interfaces.map(function (iface) {\n        return createNamedStub(iface.name.value, 'interface');\n      });\n    },\n    description: getDescription(node, backcompatOptions)\n  };\n  return new GraphQLObjectType(config);\n}\n\nfunction makeInterfaceType(node) {\n  var config = {\n    name: node.name.value,\n    fields: function fields() {\n      return makeFields(node.fields);\n    },\n    interfaces: graphqlVersion() >= 15 ? function () {\n      return node.interfaces.map(function (iface) {\n        return createNamedStub(iface.name.value, 'interface');\n      });\n    } : undefined,\n    description: getDescription(node, backcompatOptions),\n    resolveType: function resolveType(parent) {\n      return resolveFromParentTypename(parent);\n    }\n  };\n  return new GraphQLInterfaceType(config);\n}\n\nfunction makeEnumType(node) {\n  var values = keyValMap(node.values, function (value) {\n    return value.name.value;\n  }, function (value) {\n    return {\n      description: getDescription(value, backcompatOptions)\n    };\n  });\n  return new GraphQLEnumType({\n    name: node.name.value,\n    values: values,\n    description: getDescription(node, backcompatOptions)\n  });\n}\n\nfunction makeUnionType(node) {\n  return new GraphQLUnionType({\n    name: node.name.value,\n    types: function types() {\n      return node.types.map(function (type) {\n        return createNamedStub(type.name.value, 'object');\n      });\n    },\n    description: getDescription(node, backcompatOptions),\n    resolveType: function resolveType(parent) {\n      return resolveFromParentTypename(parent);\n    }\n  });\n}\n\nfunction makeScalarType(node) {\n  return new GraphQLScalarType({\n    name: node.name.value,\n    description: getDescription(node, backcompatOptions),\n    serialize: function serialize() {\n      return null;\n    },\n    // Note: validation calls the parse functions to determine if a\n    // literal value is correct. Returning null would cause use of custom\n    // scalars to always fail validation. Returning false causes them to\n    // always pass validation.\n    parseValue: function parseValue() {\n      return false;\n    },\n    parseLiteral: function parseLiteral() {\n      return false;\n    }\n  });\n}\n\nfunction makeInputObjectType(node) {\n  return new GraphQLInputObjectType({\n    name: node.name.value,\n    fields: function fields() {\n      return makeValues(node.fields);\n    },\n    description: getDescription(node, backcompatOptions)\n  });\n}\n\nfunction makeFields(nodes) {\n  return keyValMap(nodes, function (node) {\n    return node.name.value;\n  }, function (node) {\n    var deprecatedDirective = node.directives.find(function (directive) {\n      return directive.name.value === 'deprecated';\n    });\n    var deprecationReason;\n\n    if (deprecatedDirective != null) {\n      var deprecatedArgument = deprecatedDirective.arguments.find(function (arg) {\n        return arg.name.value === 'reason';\n      });\n      deprecationReason = deprecatedArgument.value.value;\n    }\n\n    return {\n      type: createStub(node.type, 'output'),\n      args: makeValues(node.arguments),\n      description: getDescription(node, backcompatOptions),\n      deprecationReason: deprecationReason\n    };\n  });\n}\n\nfunction makeValues(nodes) {\n  return keyValMap(nodes, function (node) {\n    return node.name.value;\n  }, function (node) {\n    var type = createStub(node.type, 'input');\n    return {\n      type: type,\n      defaultValue: node.defaultValue,\n      description: getDescription(node, backcompatOptions)\n    };\n  });\n}\n\nfunction makeDirective(node) {\n  var locations = [];\n  node.locations.forEach(function (location) {\n    if (location.value in DirectiveLocation) {\n      locations.push(location.value);\n    }\n  });\n  return new GraphQLDirective({\n    name: node.name.value,\n    description: node.description != null ? node.description.value : null,\n    args: makeValues(node.arguments),\n    locations: locations\n  });\n} // graphql < v13 does not export getDescription\n\n\nfunction getDescription(node, options) {\n  if (node.description != null) {\n    return node.description.value;\n  }\n\n  if (options.commentDescriptions) {\n    var rawValue = getLeadingCommentBlock(node);\n\n    if (rawValue !== undefined) {\n      return dedentBlockStringValue(\"\\n\" + rawValue);\n    }\n  }\n}\n\nfunction getLeadingCommentBlock(node) {\n  var loc = node.loc;\n\n  if (!loc) {\n    return;\n  }\n\n  var comments = [];\n  var token = loc.startToken.prev;\n\n  while (token != null && token.kind === TokenKind.COMMENT && token.next != null && token.prev != null && token.line + 1 === token.next.line && token.line !== token.prev.line) {\n    var value = String(token.value);\n    comments.push(value);\n    token = token.prev;\n  }\n\n  return comments.length > 0 ? comments.reverse().join('\\n') : undefined;\n}\n\nfunction dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n}\n/**\r\n * @internal\r\n */\n\n\nfunction getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n\nfunction concatInlineFragments(type, fragments) {\n  var fragmentSelections = fragments.reduce(function (selections, fragment) {\n    return selections.concat(fragment.selectionSet.selections);\n  }, []);\n  var deduplicatedFragmentSelection = deduplicateSelection(fragmentSelections);\n  return {\n    kind: Kind.INLINE_FRAGMENT,\n    typeCondition: {\n      kind: Kind.NAMED_TYPE,\n      name: {\n        kind: Kind.NAME,\n        value: type\n      }\n    },\n    selectionSet: {\n      kind: Kind.SELECTION_SET,\n      selections: deduplicatedFragmentSelection\n    }\n  };\n}\n\nfunction deduplicateSelection(nodes) {\n  var selectionMap = nodes.reduce(function (map, node) {\n    var _a, _b, _c;\n\n    switch (node.kind) {\n      case 'Field':\n        {\n          if (node.alias != null) {\n            if (node.alias.value in map) {\n              return map;\n            }\n\n            return __assign(__assign({}, map), (_a = {}, _a[node.alias.value] = node, _a));\n          }\n\n          if (node.name.value in map) {\n            return map;\n          }\n\n          return __assign(__assign({}, map), (_b = {}, _b[node.name.value] = node, _b));\n        }\n\n      case 'FragmentSpread':\n        {\n          if (node.name.value in map) {\n            return map;\n          }\n\n          return __assign(__assign({}, map), (_c = {}, _c[node.name.value] = node, _c));\n        }\n\n      case 'InlineFragment':\n        {\n          if (map.__fragment != null) {\n            var fragment = map.__fragment;\n            return __assign(__assign({}, map), {\n              __fragment: concatInlineFragments(fragment.typeCondition.name.value, [fragment, node])\n            });\n          }\n\n          return __assign(__assign({}, map), {\n            __fragment: node\n          });\n        }\n\n      default:\n        {\n          return map;\n        }\n    }\n  }, Object.create(null));\n  var selection = Object.keys(selectionMap).reduce(function (selectionList, node) {\n    return selectionList.concat(selectionMap[node]);\n  }, []);\n  return selection;\n}\n\nfunction parseFragmentToInlineFragment(definitions) {\n  if (definitions.trim().startsWith('fragment')) {\n    var document_1 = parse(definitions);\n\n    for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n      var definition = _a[_i];\n\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet\n        };\n      }\n    }\n  }\n\n  var query = parse(\"{\" + definitions + \"}\").definitions[0];\n\n  for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n    var selection = _c[_b];\n\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n\nfunction parseSelectionSet(selectionSet) {\n  var query = parse(selectionSet).definitions[0];\n  return query.selectionSet;\n}\n\nfunction typeContainsSelectionSet(type, selectionSet) {\n  var fields = type.getFields();\n\n  for (var _i = 0, _a = selectionSet.selections; _i < _a.length; _i++) {\n    var selection = _a[_i];\n\n    if (selection.kind === Kind.FIELD) {\n      var field = fields[selection.name.value];\n\n      if (field == null) {\n        return false;\n      }\n\n      if (selection.selectionSet != null) {\n        return typeContainsSelectionSet(getNamedType(field.type), selection.selectionSet);\n      }\n    } else if (selection.kind === Kind.INLINE_FRAGMENT) {\n      var containsSelectionSet = typeContainsSelectionSet(type, selection.selectionSet);\n\n      if (!containsSelectionSet) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\nfunction createMergeInfo(allSchemas, typeCandidates, mergeTypes) {\n  return {\n    delegate: function delegate(operation, fieldName, args, context, info, transforms) {\n      if (transforms === void 0) {\n        transforms = [];\n      }\n\n      var schema = guessSchemaByRootField(allSchemas, operation, fieldName);\n      var expandTransforms = new ExpandAbstractTypes(info.schema, schema);\n      var fragmentTransform = new AddReplacementFragments(schema, info.mergeInfo.replacementFragments);\n      return _delegateToSchema({\n        schema: schema,\n        operation: operation,\n        fieldName: fieldName,\n        args: args,\n        context: context,\n        info: info,\n        transforms: __spreadArrays(transforms, [expandTransforms, fragmentTransform])\n      });\n    },\n    delegateToSchema: function delegateToSchema(options) {\n      return _delegateToSchema(__assign(__assign({}, options), {\n        transforms: options.transforms\n      }));\n    },\n    fragments: [],\n    replacementSelectionSets: undefined,\n    replacementFragments: undefined,\n    mergedTypes: createMergedTypes(typeCandidates, mergeTypes)\n  };\n}\n\nfunction createMergedTypes(typeCandidates, mergeTypes) {\n  var mergedTypes = Object.create(null);\n  Object.keys(typeCandidates).forEach(function (typeName) {\n    if (isObjectType(typeCandidates[typeName][0].type)) {\n      var mergedTypeCandidates = typeCandidates[typeName].filter(function (typeCandidate) {\n        return typeCandidate.subschema != null && isSubschemaConfig(typeCandidate.subschema) && typeCandidate.subschema.merge != null && hasOwnProperty(typeCandidate.subschema.merge, typeName);\n      });\n\n      if (mergeTypes === true || typeof mergeTypes === 'function' && mergeTypes(typeName, typeCandidates[typeName]) || Array.isArray(mergeTypes) && mergeTypes.includes(typeName) || mergedTypeCandidates.length) {\n        var subschemas_1 = [];\n        var requiredSelections_1 = [parseSelectionSet('{ __typename }').selections[0]];\n        var fields_1 = Object.create({});\n        var typeMaps_1 = new Map();\n        var selectionSets_1 = new Map();\n        mergedTypeCandidates.forEach(function (typeCandidate) {\n          var subschemaConfig = typeCandidate.subschema;\n          var transformedSubschema = typeCandidate.transformedSubschema;\n          typeMaps_1.set(subschemaConfig, transformedSubschema.getTypeMap());\n          var type = transformedSubschema.getType(typeName);\n          var fieldMap = type.getFields();\n          Object.keys(fieldMap).forEach(function (fieldName) {\n            if (!(fieldName in fields_1)) {\n              fields_1[fieldName] = [];\n            }\n\n            fields_1[fieldName].push(subschemaConfig);\n          });\n          var mergedTypeConfig = subschemaConfig.merge[typeName];\n\n          if (mergedTypeConfig.selectionSet) {\n            var selectionSet = parseSelectionSet(mergedTypeConfig.selectionSet);\n            requiredSelections_1 = requiredSelections_1.concat(selectionSet.selections);\n            selectionSets_1.set(subschemaConfig, selectionSet);\n          }\n\n          if (!mergedTypeConfig.resolve) {\n            mergedTypeConfig.resolve = function (originalResult, context, info, subschema, selectionSet) {\n              return _delegateToSchema({\n                schema: subschema,\n                operation: 'query',\n                fieldName: mergedTypeConfig.fieldName,\n                args: mergedTypeConfig.args(originalResult),\n                selectionSet: selectionSet,\n                context: context,\n                info: info,\n                skipTypeMerging: true\n              });\n            };\n          }\n\n          subschemas_1.push(subschemaConfig);\n        });\n        mergedTypes[typeName] = {\n          subschemas: subschemas_1,\n          typeMaps: typeMaps_1,\n          selectionSets: selectionSets_1,\n          containsSelectionSet: new Map(),\n          uniqueFields: Object.create({}),\n          nonUniqueFields: Object.create({})\n        };\n        subschemas_1.forEach(function (subschema) {\n          var type = typeMaps_1.get(subschema)[typeName];\n          var subschemaMap = new Map();\n          subschemas_1.filter(function (s) {\n            return s !== subschema;\n          }).forEach(function (s) {\n            var selectionSet = selectionSets_1.get(s);\n\n            if (selectionSet != null && typeContainsSelectionSet(type, selectionSet)) {\n              subschemaMap.set(selectionSet, true);\n            }\n          });\n          mergedTypes[typeName].containsSelectionSet.set(subschema, subschemaMap);\n        });\n        Object.keys(fields_1).forEach(function (fieldName) {\n          var supportedBySubschemas = fields_1[fieldName];\n\n          if (supportedBySubschemas.length === 1) {\n            mergedTypes[typeName].uniqueFields[fieldName] = supportedBySubschemas[0];\n          } else {\n            mergedTypes[typeName].nonUniqueFields[fieldName] = supportedBySubschemas;\n          }\n        });\n        mergedTypes[typeName].selectionSet = {\n          kind: Kind.SELECTION_SET,\n          selections: requiredSelections_1\n        };\n      }\n    }\n  });\n  return mergedTypes;\n}\n\nfunction completeMergeInfo(mergeInfo, resolvers) {\n  var replacementSelectionSets = Object.create(null);\n  Object.keys(resolvers).forEach(function (typeName) {\n    var type = resolvers[typeName];\n\n    if (isScalarType(type)) {\n      return;\n    }\n\n    Object.keys(type).forEach(function (fieldName) {\n      var field = type[fieldName];\n\n      if (field.selectionSet) {\n        var selectionSet = parseSelectionSet(field.selectionSet);\n\n        if (!(typeName in replacementSelectionSets)) {\n          replacementSelectionSets[typeName] = Object.create(null);\n        }\n\n        var typeReplacementSelectionSets = replacementSelectionSets[typeName];\n\n        if (!(fieldName in typeReplacementSelectionSets)) {\n          typeReplacementSelectionSets[fieldName] = {\n            kind: Kind.SELECTION_SET,\n            selections: []\n          };\n        }\n\n        typeReplacementSelectionSets[fieldName].selections = typeReplacementSelectionSets[fieldName].selections.concat(selectionSet.selections);\n      }\n\n      if (field.fragment) {\n        mergeInfo.fragments.push({\n          field: fieldName,\n          fragment: field.fragment\n        });\n      }\n    });\n  });\n  var mapping = Object.create(null);\n  mergeInfo.fragments.forEach(function (_a) {\n    var field = _a.field,\n        fragment = _a.fragment;\n    var parsedFragment = parseFragmentToInlineFragment(fragment);\n    var actualTypeName = parsedFragment.typeCondition.name.value;\n\n    if (!(actualTypeName in mapping)) {\n      mapping[actualTypeName] = Object.create(null);\n    }\n\n    var typeMapping = mapping[actualTypeName];\n\n    if (!(field in typeMapping)) {\n      typeMapping[field] = [];\n    }\n\n    typeMapping[field].push(parsedFragment);\n  });\n  var replacementFragments = Object.create(null);\n  Object.keys(mapping).forEach(function (typeName) {\n    Object.keys(mapping[typeName]).forEach(function (field) {\n      if (!(typeName in replacementFragments)) {\n        replacementFragments[typeName] = Object.create(null);\n      }\n\n      var typeReplacementFragments = replacementFragments[typeName];\n      typeReplacementFragments[field] = concatInlineFragments(typeName, mapping[typeName][field]);\n    });\n  });\n  mergeInfo.replacementSelectionSets = replacementSelectionSets;\n  mergeInfo.replacementFragments = replacementFragments;\n  return mergeInfo;\n}\n\nfunction operationToRootType(operation, schema) {\n  if (operation === 'subscription') {\n    return schema.getSubscriptionType();\n  } else if (operation === 'mutation') {\n    return schema.getMutationType();\n  }\n\n  return schema.getQueryType();\n}\n\nfunction guessSchemaByRootField(schemas, operation, fieldName) {\n  for (var _i = 0, schemas_1 = schemas; _i < schemas_1.length; _i++) {\n    var schema = schemas_1[_i];\n    var rootObject = operationToRootType(operation, schema);\n\n    if (rootObject != null) {\n      var fields = rootObject.getFields();\n\n      if (fieldName in fields) {\n        return schema;\n      }\n    }\n  }\n\n  throw new Error(\"Could not find subschema with field `\" + operation + \".\" + fieldName + \"`\");\n}\n\nfunction mergeSchemas(_a) {\n  var _b = _a.subschemas,\n      subschemas = _b === void 0 ? [] : _b,\n      _c = _a.types,\n      types = _c === void 0 ? [] : _c,\n      typeDefs = _a.typeDefs,\n      _d = _a.schemas,\n      schemaLikeObjects = _d === void 0 ? [] : _d,\n      onTypeConflict = _a.onTypeConflict,\n      _e = _a.resolvers,\n      resolvers = _e === void 0 ? {} : _e,\n      schemaDirectives = _a.schemaDirectives,\n      inheritResolversFromInterfaces = _a.inheritResolversFromInterfaces,\n      _f = _a.mergeTypes,\n      mergeTypes = _f === void 0 ? false : _f,\n      mergeDirectives = _a.mergeDirectives,\n      _g = _a.queryTypeName,\n      queryTypeName = _g === void 0 ? 'Query' : _g,\n      _h = _a.mutationTypeName,\n      mutationTypeName = _h === void 0 ? 'Mutation' : _h,\n      _j = _a.subscriptionTypeName,\n      subscriptionTypeName = _j === void 0 ? 'Subscription' : _j;\n  var allSchemas = [];\n  var typeCandidates = Object.create(null);\n  var typeMap = Object.create(null);\n  var extensions = [];\n  var directives = [];\n\n  var schemas = __spreadArrays(subschemas);\n\n  if (typeDefs) {\n    schemas.push(typeDefs);\n  }\n\n  if (types != null) {\n    schemas.push(types);\n  }\n\n  schemas = __spreadArrays(schemas, schemaLikeObjects);\n  schemas.forEach(function (schemaLikeObject) {\n    var _a;\n\n    if (isSchema(schemaLikeObject) || isSubschemaConfig(schemaLikeObject)) {\n      var schema_1 = wrapSchema(schemaLikeObject);\n      allSchemas.push(schema_1);\n      var operationTypes_1 = (_a = {}, _a[queryTypeName] = schema_1.getQueryType(), _a[mutationTypeName] = schema_1.getMutationType(), _a[subscriptionTypeName] = schema_1.getSubscriptionType(), _a);\n      Object.keys(operationTypes_1).forEach(function (typeName) {\n        if (operationTypes_1[typeName] != null) {\n          addTypeCandidate(typeCandidates, typeName, {\n            schema: schema_1,\n            type: operationTypes_1[typeName],\n            subschema: schemaLikeObject,\n            transformedSubschema: schema_1\n          });\n        }\n      });\n\n      if (mergeDirectives) {\n        var directiveInstances = schema_1.getDirectives();\n        directiveInstances.forEach(function (directive) {\n          directives.push(directive);\n        });\n      }\n\n      var originalTypeMap_1 = schema_1.getTypeMap();\n      Object.keys(originalTypeMap_1).forEach(function (typeName) {\n        var type = originalTypeMap_1[typeName];\n\n        if (isNamedType(type) && getNamedType(type).name.slice(0, 2) !== '__' && type !== operationTypes_1.Query && type !== operationTypes_1.Mutation && type !== operationTypes_1.Subscription) {\n          addTypeCandidate(typeCandidates, type.name, {\n            schema: schema_1,\n            type: type,\n            subschema: schemaLikeObject,\n            transformedSubschema: schema_1\n          });\n        }\n      });\n    } else if (typeof schemaLikeObject === 'string' || schemaLikeObject != null && schemaLikeObject.kind === Kind.DOCUMENT) {\n      var parsedSchemaDocument = typeof schemaLikeObject === 'string' ? parse(schemaLikeObject) : schemaLikeObject;\n      parsedSchemaDocument.definitions.forEach(function (def) {\n        var type = typeFromAST(def);\n\n        if (isDirective(type) && mergeDirectives) {\n          directives.push(type);\n        } else if (type != null && !isDirective(type)) {\n          addTypeCandidate(typeCandidates, type.name, {\n            type: type\n          });\n        }\n      });\n      var extensionsDocument = extractExtensionDefinitions(parsedSchemaDocument);\n\n      if (extensionsDocument.definitions.length > 0) {\n        extensions.push(extensionsDocument);\n      }\n    } else if (Array.isArray(schemaLikeObject)) {\n      schemaLikeObject.forEach(function (type) {\n        addTypeCandidate(typeCandidates, type.name, {\n          type: type\n        });\n      });\n    } else {\n      throw new Error('Invalid schema passed');\n    }\n  });\n  var mergeInfo = createMergeInfo(allSchemas, typeCandidates, mergeTypes);\n  var finalResolvers;\n\n  if (typeof resolvers === 'function') {\n    finalResolvers = resolvers(mergeInfo);\n  } else if (Array.isArray(resolvers)) {\n    finalResolvers = resolvers.reduce(function (left, right) {\n      return mergeDeep(left, typeof right === 'function' ? right(mergeInfo) : right);\n    }, {});\n\n    if (Array.isArray(resolvers)) {\n      finalResolvers = resolvers.reduce(mergeDeep, {});\n    }\n  } else {\n    finalResolvers = resolvers;\n  }\n\n  if (finalResolvers == null) {\n    finalResolvers = {};\n  }\n\n  mergeInfo = completeMergeInfo(mergeInfo, finalResolvers);\n  Object.keys(typeCandidates).forEach(function (typeName) {\n    if (typeName === queryTypeName || typeName === mutationTypeName || typeName === subscriptionTypeName || mergeTypes === true && !isScalarType(typeCandidates[typeName][0].type) || typeof mergeTypes === 'function' && mergeTypes(typeName, typeCandidates[typeName]) || Array.isArray(mergeTypes) && mergeTypes.includes(typeName) || typeName in mergeInfo.mergedTypes) {\n      typeMap[typeName] = merge(typeName, typeCandidates[typeName]);\n    } else {\n      var candidateSelector = onTypeConflict != null ? onTypeConflictToCandidateSelector(onTypeConflict) : function (cands) {\n        return cands[cands.length - 1];\n      };\n      typeMap[typeName] = candidateSelector(typeCandidates[typeName]).type;\n    }\n  });\n  healTypes(typeMap, directives, {\n    skipPruning: true\n  });\n  var mergedSchema = new GraphQLSchema({\n    query: typeMap[queryTypeName],\n    mutation: typeMap[mutationTypeName],\n    subscription: typeMap[subscriptionTypeName],\n    types: Object.keys(typeMap).map(function (key) {\n      return typeMap[key];\n    }),\n    directives: directives.length ? directives.map(function (directive) {\n      return cloneDirective(directive);\n    }) : undefined\n  });\n  extensions.forEach(function (extension) {\n    mergedSchema = extendSchema(mergedSchema, extension, {\n      commentDescriptions: true\n    });\n  });\n  addResolversToSchema({\n    schema: mergedSchema,\n    resolvers: finalResolvers,\n    inheritResolversFromInterfaces: inheritResolversFromInterfaces\n  });\n  forEachField(mergedSchema, function (field) {\n    if (field.resolve != null) {\n      var fieldResolver_1 = field.resolve;\n\n      field.resolve = function (parent, args, context, info) {\n        var newInfo = __assign(__assign({}, info), {\n          mergeInfo: mergeInfo\n        });\n\n        return fieldResolver_1(parent, args, context, newInfo);\n      };\n    }\n\n    if (field.subscribe != null) {\n      var fieldResolver_2 = field.subscribe;\n\n      field.subscribe = function (parent, args, context, info) {\n        var newInfo = __assign(__assign({}, info), {\n          mergeInfo: mergeInfo\n        });\n\n        return fieldResolver_2(parent, args, context, newInfo);\n      };\n    }\n  });\n\n  if (schemaDirectives != null) {\n    SchemaDirectiveVisitor.visitSchemaDirectives(mergedSchema, schemaDirectives);\n  }\n\n  return mergedSchema;\n}\n\nfunction addTypeCandidate(typeCandidates, name, typeCandidate) {\n  if (!(name in typeCandidates)) {\n    typeCandidates[name] = [];\n  }\n\n  typeCandidates[name].push(typeCandidate);\n}\n\nfunction onTypeConflictToCandidateSelector(onTypeConflict) {\n  return function (cands) {\n    return cands.reduce(function (prev, next) {\n      var type = onTypeConflict(prev.type, next.type, {\n        left: {\n          schema: prev.schema\n        },\n        right: {\n          schema: next.schema\n        }\n      });\n\n      if (prev.type === type) {\n        return prev;\n      } else if (next.type === type) {\n        return next;\n      }\n\n      return {\n        schemaName: 'unknown',\n        type: type\n      };\n    });\n  };\n}\n\nfunction merge(typeName, candidates) {\n  var initialCandidateType = candidates[0].type;\n\n  if (candidates.some(function (candidate) {\n    return candidate.type.constructor !== initialCandidateType.constructor;\n  })) {\n    throw new Error(\"Cannot merge different type categories into common type \" + typeName + \".\");\n  }\n\n  if (isObjectType(initialCandidateType)) {\n    return new GraphQLObjectType({\n      name: typeName,\n      fields: candidates.reduce(function (acc, candidate) {\n        return __assign(__assign({}, acc), toConfig(candidate.type).fields);\n      }, {}),\n      interfaces: candidates.reduce(function (acc, candidate) {\n        var interfaces = toConfig(candidate.type).interfaces;\n        return interfaces != null ? acc.concat(interfaces) : acc;\n      }, [])\n    });\n  } else if (isInterfaceType(initialCandidateType)) {\n    var config = {\n      name: typeName,\n      fields: candidates.reduce(function (acc, candidate) {\n        return __assign(__assign({}, acc), toConfig(candidate.type).fields);\n      }, {}),\n      interfaces: graphqlVersion() >= 15 ? candidates.reduce(function (acc, candidate) {\n        var interfaces = toConfig(candidate.type).interfaces;\n        return interfaces != null ? acc.concat(interfaces) : acc;\n      }, []) : undefined\n    };\n    return new GraphQLInterfaceType(config);\n  } else if (isUnionType(initialCandidateType)) {\n    return new GraphQLUnionType({\n      name: typeName,\n      types: candidates.reduce(function (acc, candidate) {\n        return acc.concat(toConfig(candidate.type).types);\n      }, [])\n    });\n  } else if (isEnumType(initialCandidateType)) {\n    return new GraphQLEnumType({\n      name: typeName,\n      values: candidates.reduce(function (acc, candidate) {\n        return __assign(__assign({}, acc), toConfig(candidate.type).values);\n      }, {})\n    });\n  } else if (isScalarType(initialCandidateType)) {\n    throw new Error(\"Cannot merge type \" + typeName + \". Merging not supported for GraphQLScalarType.\");\n  } else {\n    // not reachable.\n    throw new Error(\"Type \" + typeName + \" has unknown GraphQL type.\");\n  }\n} // This function is deprecated in favor of wrapSchema as the name is misleading.\n// transformSchema does not just \"transform\" a schema, it wraps a schema with transforms\n// using a round of delegation.\n// The applySchemaTransforms function actually \"transforms\" the schema and is used during wrapping.\n\n\nfunction transformSchema(subschemaOrSubschemaConfig, transforms) {\n  var schema = wrapSchema(subschemaOrSubschemaConfig, transforms);\n  schema.transforms = transforms.slice().reverse();\n  return schema;\n}\n\nvar RenameTypes =\n/** @class */\nfunction () {\n  function RenameTypes(renamer, options) {\n    this.renamer = renamer;\n    this.map = Object.create(null);\n    this.reverseMap = Object.create(null);\n\n    var _a = options != null ? options : {},\n        _b = _a.renameBuiltins,\n        renameBuiltins = _b === void 0 ? false : _b,\n        _c = _a.renameScalars,\n        renameScalars = _c === void 0 ? true : _c;\n\n    this.renameBuiltins = renameBuiltins;\n    this.renameScalars = renameScalars;\n  }\n\n  RenameTypes.prototype.transformSchema = function (originalSchema) {\n    var _a;\n\n    var _this = this;\n\n    return mapSchema(originalSchema, (_a = {}, _a[MapperKind.TYPE] = function (type) {\n      if (isSpecifiedScalarType(type) && !_this.renameBuiltins) {\n        return undefined;\n      }\n\n      if (isScalarType(type) && !_this.renameScalars) {\n        return undefined;\n      }\n\n      var oldName = type.name;\n\n      var newName = _this.renamer(oldName);\n\n      if (newName !== undefined && newName !== oldName) {\n        _this.map[oldName] = newName;\n        _this.reverseMap[newName] = oldName;\n\n        var newConfig = __assign(__assign({}, toConfig(type)), {\n          name: newName\n        });\n\n        if (isObjectType(type)) {\n          return new GraphQLObjectType(newConfig);\n        } else if (isInterfaceType(type)) {\n          return new GraphQLInterfaceType(newConfig);\n        } else if (isUnionType(type)) {\n          return new GraphQLUnionType(newConfig);\n        } else if (isInputObjectType(type)) {\n          return new GraphQLInputObjectType(newConfig);\n        } else if (isEnumType(type)) {\n          return new GraphQLEnumType(newConfig);\n        } else if (isScalarType(type)) {\n          return new GraphQLScalarType(newConfig);\n        }\n\n        throw new Error(\"Unknown type \" + type + \".\");\n      }\n    }, _a[MapperKind.ROOT_OBJECT] = function () {\n      return undefined;\n    }, _a));\n  };\n\n  RenameTypes.prototype.transformRequest = function (originalRequest) {\n    var _a;\n\n    var _this = this;\n\n    var newDocument = visit(originalRequest.document, (_a = {}, _a[Kind.NAMED_TYPE] = function (node) {\n      var name = node.name.value;\n\n      if (name in _this.reverseMap) {\n        return __assign(__assign({}, node), {\n          name: {\n            kind: Kind.NAME,\n            value: _this.reverseMap[name]\n          }\n        });\n      }\n    }, _a));\n    return {\n      document: newDocument,\n      variables: originalRequest.variables\n    };\n  };\n\n  RenameTypes.prototype.transformResult = function (result) {\n    return __assign(__assign({}, result), {\n      data: this.transformData(result.data)\n    });\n  };\n\n  RenameTypes.prototype.transformData = function (data) {\n    var _this = this;\n\n    if (data == null) {\n      return data;\n    } else if (Array.isArray(data)) {\n      return data.map(function (value) {\n        return _this.transformData(value);\n      });\n    } else if (_typeof(data) === 'object') {\n      return this.transformObject(data);\n    }\n\n    return data;\n  };\n\n  RenameTypes.prototype.transformObject = function (object) {\n    var _this = this;\n\n    Object.keys(object).forEach(function (key) {\n      var value = object[key];\n\n      if (key === '__typename') {\n        if (value in _this.map) {\n          object[key] = _this.map[value];\n        }\n      } else {\n        object[key] = _this.transformData(value);\n      }\n    });\n    return object;\n  };\n\n  return RenameTypes;\n}();\n\nvar FilterTypes =\n/** @class */\nfunction () {\n  function FilterTypes(filter) {\n    this.filter = filter;\n  }\n\n  FilterTypes.prototype.transformSchema = function (schema) {\n    var _a;\n\n    var _this = this;\n\n    return mapSchema(schema, (_a = {}, _a[MapperKind.TYPE] = function (type) {\n      if (_this.filter(type)) {\n        return undefined;\n      }\n\n      return null;\n    }, _a));\n  };\n\n  return FilterTypes;\n}();\n\nvar RenameRootTypes =\n/** @class */\nfunction () {\n  function RenameRootTypes(renamer) {\n    this.renamer = renamer;\n    this.map = Object.create(null);\n    this.reverseMap = Object.create(null);\n  }\n\n  RenameRootTypes.prototype.transformSchema = function (originalSchema) {\n    var _a;\n\n    var _this = this;\n\n    return mapSchema(originalSchema, (_a = {}, _a[MapperKind.ROOT_OBJECT] = function (type) {\n      var oldName = type.name;\n\n      var newName = _this.renamer(oldName);\n\n      if (newName !== undefined && newName !== oldName) {\n        _this.map[oldName] = newName;\n        _this.reverseMap[newName] = oldName;\n        return new GraphQLObjectType(__assign(__assign({}, toConfig(type)), {\n          name: newName\n        }));\n      }\n    }, _a));\n  };\n\n  RenameRootTypes.prototype.transformRequest = function (originalRequest) {\n    var _a;\n\n    var _this = this;\n\n    var newDocument = visit(originalRequest.document, (_a = {}, _a[Kind.NAMED_TYPE] = function (node) {\n      var name = node.name.value;\n\n      if (name in _this.reverseMap) {\n        return __assign(__assign({}, node), {\n          name: {\n            kind: Kind.NAME,\n            value: _this.reverseMap[name]\n          }\n        });\n      }\n    }, _a));\n    return {\n      document: newDocument,\n      variables: originalRequest.variables\n    };\n  };\n\n  RenameRootTypes.prototype.transformResult = function (result) {\n    return __assign(__assign({}, result), {\n      data: this.transformData(result.data)\n    });\n  };\n\n  RenameRootTypes.prototype.transformData = function (data) {\n    var _this = this;\n\n    if (data == null) {\n      return data;\n    } else if (Array.isArray(data)) {\n      return data.map(function (value) {\n        return _this.transformData(value);\n      });\n    } else if (_typeof(data) === 'object') {\n      return this.transformObject(data);\n    }\n\n    return data;\n  };\n\n  RenameRootTypes.prototype.transformObject = function (object) {\n    var _this = this;\n\n    Object.keys(object).forEach(function (key) {\n      var value = object[key];\n\n      if (key === '__typename') {\n        if (value in _this.map) {\n          object[key] = _this.map[value];\n        }\n      } else {\n        object[key] = _this.transformData(value);\n      }\n    });\n    return object;\n  };\n\n  return RenameRootTypes;\n}();\n\nfunction isEmptyObject(obj) {\n  if (obj == null) {\n    return true;\n  }\n\n  return Object.keys(obj).length === 0;\n}\n\nvar TransformCompositeFields =\n/** @class */\nfunction () {\n  function TransformCompositeFields(fieldTransformer, fieldNodeTransformer) {\n    this.fieldTransformer = fieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n    this.mapping = {};\n  }\n\n  TransformCompositeFields.prototype.transformSchema = function (originalSchema) {\n    var _a;\n\n    var _this = this;\n\n    this.transformedSchema = mapSchema(originalSchema, (_a = {}, _a[MapperKind.OBJECT_TYPE] = function (type) {\n      return _this.transformFields(type, _this.fieldTransformer);\n    }, _a[MapperKind.INTERFACE_TYPE] = function (type) {\n      return _this.transformFields(type, _this.fieldTransformer);\n    }, _a));\n    return this.transformedSchema;\n  };\n\n  TransformCompositeFields.prototype.transformRequest = function (originalRequest) {\n    var fragments = Object.create(null);\n    originalRequest.document.definitions.filter(function (def) {\n      return def.kind === Kind.FRAGMENT_DEFINITION;\n    }).forEach(function (def) {\n      fragments[def.name.value] = def;\n    });\n    var document = this.transformDocument(originalRequest.document, this.mapping, this.fieldNodeTransformer, fragments);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  TransformCompositeFields.prototype.transformFields = function (type, fieldTransformer) {\n    var _this = this;\n\n    var typeConfig = toConfig(type);\n    var fields = type.getFields();\n    var newFields = {};\n    Object.keys(fields).forEach(function (fieldName) {\n      var field = fields[fieldName];\n      var transformedField = fieldTransformer(type.name, fieldName, field);\n\n      if (typeof transformedField === 'undefined') {\n        newFields[fieldName] = typeConfig.fields[fieldName];\n      } else if (transformedField !== null) {\n        var newName = transformedField.name;\n\n        if (newName) {\n          newFields[newName] = transformedField.field != null ? transformedField.field : typeConfig.fields[fieldName];\n\n          if (newName !== fieldName) {\n            var typeName = type.name;\n\n            if (!(typeName in _this.mapping)) {\n              _this.mapping[typeName] = {};\n            }\n\n            _this.mapping[typeName][newName] = fieldName;\n          }\n        } else {\n          newFields[fieldName] = transformedField;\n        }\n      }\n    });\n\n    if (isEmptyObject(newFields)) {\n      return null;\n    }\n\n    if (isObjectType(type)) {\n      return new GraphQLObjectType(__assign(__assign({}, toConfig(type)), {\n        fields: newFields\n      }));\n    } else if (isInterfaceType(type)) {\n      return new GraphQLInterfaceType(__assign(__assign({}, toConfig(type)), {\n        fields: newFields\n      }));\n    }\n  };\n\n  TransformCompositeFields.prototype.transformDocument = function (document, mapping, fieldNodeTransformer, fragments) {\n    var _a;\n\n    if (fragments === void 0) {\n      fragments = {};\n    }\n\n    var typeInfo = new TypeInfo(this.transformedSchema);\n    var newDocument = visit(document, visitWithTypeInfo(typeInfo, {\n      leave: (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n        var parentType = typeInfo.getParentType();\n\n        if (parentType != null) {\n          var parentTypeName_1 = parentType.name;\n          var newSelections_1 = [];\n          node.selections.forEach(function (selection) {\n            if (selection.kind !== Kind.FIELD) {\n              newSelections_1.push(selection);\n              return;\n            }\n\n            var newName = selection.name.value;\n            var transformedSelection = fieldNodeTransformer != null ? fieldNodeTransformer(parentTypeName_1, newName, selection, fragments) : selection;\n\n            if (Array.isArray(transformedSelection)) {\n              newSelections_1 = newSelections_1.concat(transformedSelection);\n              return;\n            }\n\n            if (transformedSelection.kind !== Kind.FIELD) {\n              newSelections_1.push(transformedSelection);\n              return;\n            }\n\n            var typeMapping = mapping[parentTypeName_1];\n\n            if (typeMapping == null) {\n              newSelections_1.push(transformedSelection);\n              return;\n            }\n\n            var oldName = mapping[parentTypeName_1][newName];\n\n            if (oldName == null) {\n              newSelections_1.push(transformedSelection);\n              return;\n            }\n\n            newSelections_1.push(__assign(__assign({}, transformedSelection), {\n              name: {\n                kind: Kind.NAME,\n                value: oldName\n              },\n              alias: {\n                kind: Kind.NAME,\n                value: newName\n              }\n            }));\n          });\n          return __assign(__assign({}, node), {\n            selections: newSelections_1\n          });\n        }\n      }, _a)\n    }));\n    return newDocument;\n  };\n\n  return TransformCompositeFields;\n}();\n\nvar TransformObjectFields =\n/** @class */\nfunction () {\n  function TransformObjectFields(objectFieldTransformer, fieldNodeTransformer) {\n    this.objectFieldTransformer = objectFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  TransformObjectFields.prototype.transformSchema = function (originalSchema) {\n    var _this = this;\n\n    var compositeToObjectFieldTransformer = function compositeToObjectFieldTransformer(typeName, fieldName, field) {\n      if (isObjectType(originalSchema.getType(typeName))) {\n        return _this.objectFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  TransformObjectFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return TransformObjectFields;\n}();\n\nvar TransformRootFields =\n/** @class */\nfunction () {\n  function TransformRootFields(rootFieldTransformer, fieldNodeTransformer) {\n    var rootToObjectFieldTransformer = function rootToObjectFieldTransformer(typeName, fieldName, field) {\n      if (typeName === 'Query' || typeName === 'Mutation' || typeName === 'Subscription') {\n        return rootFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformObjectFields(rootToObjectFieldTransformer, fieldNodeTransformer);\n  }\n\n  TransformRootFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  TransformRootFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return TransformRootFields;\n}();\n\nvar RenameRootFields =\n/** @class */\nfunction () {\n  function RenameRootFields(renamer) {\n    this.transformer = new TransformRootFields(function (operation, fieldName, field) {\n      return {\n        name: renamer(operation, fieldName, field)\n      };\n    });\n  }\n\n  RenameRootFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  RenameRootFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return RenameRootFields;\n}();\n\nvar FilterRootFields =\n/** @class */\nfunction () {\n  function FilterRootFields(filter) {\n    this.transformer = new TransformRootFields(function (operation, fieldName, field) {\n      if (filter(operation, fieldName, field)) {\n        return undefined;\n      }\n\n      return null;\n    });\n  }\n\n  FilterRootFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  return FilterRootFields;\n}();\n\nvar RenameObjectFields =\n/** @class */\nfunction () {\n  function RenameObjectFields(renamer) {\n    this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {\n      return {\n        name: renamer(typeName, fieldName, field)\n      };\n    });\n  }\n\n  RenameObjectFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  RenameObjectFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return RenameObjectFields;\n}();\n\nvar FilterObjectFields =\n/** @class */\nfunction () {\n  function FilterObjectFields(filter) {\n    this.transformer = new TransformObjectFields(function (typeName, fieldName, field) {\n      return filter(typeName, fieldName, field) ? undefined : null;\n    });\n  }\n\n  FilterObjectFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  return FilterObjectFields;\n}();\n\nvar TransformInterfaceFields =\n/** @class */\nfunction () {\n  function TransformInterfaceFields(interfaceFieldTransformer, fieldNodeTransformer) {\n    this.interfaceFieldTransformer = interfaceFieldTransformer;\n    this.fieldNodeTransformer = fieldNodeTransformer;\n  }\n\n  TransformInterfaceFields.prototype.transformSchema = function (originalSchema) {\n    var _this = this;\n\n    var compositeToObjectFieldTransformer = function compositeToObjectFieldTransformer(typeName, fieldName, field) {\n      if (isInterfaceType(originalSchema.getType(typeName))) {\n        return _this.interfaceFieldTransformer(typeName, fieldName, field);\n      }\n\n      return undefined;\n    };\n\n    this.transformer = new TransformCompositeFields(compositeToObjectFieldTransformer, this.fieldNodeTransformer);\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  TransformInterfaceFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return TransformInterfaceFields;\n}();\n\nvar RenameInterfaceFields =\n/** @class */\nfunction () {\n  function RenameInterfaceFields(renamer) {\n    this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {\n      return {\n        name: renamer(typeName, fieldName, field)\n      };\n    });\n  }\n\n  RenameInterfaceFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  RenameInterfaceFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return RenameInterfaceFields;\n}();\n\nvar FilterInterfaceFields =\n/** @class */\nfunction () {\n  function FilterInterfaceFields(filter) {\n    this.transformer = new TransformInterfaceFields(function (typeName, fieldName, field) {\n      return filter(typeName, fieldName, field) ? undefined : null;\n    });\n  }\n\n  FilterInterfaceFields.prototype.transformSchema = function (originalSchema) {\n    return this.transformer.transformSchema(originalSchema);\n  };\n\n  return FilterInterfaceFields;\n}();\n\nvar TransformQuery =\n/** @class */\nfunction () {\n  function TransformQuery(_a) {\n    var path = _a.path,\n        queryTransformer = _a.queryTransformer,\n        _b = _a.resultTransformer,\n        resultTransformer = _b === void 0 ? function (result) {\n      return result;\n    } : _b,\n        _c = _a.errorPathTransformer,\n        errorPathTransformer = _c === void 0 ? function (errorPath) {\n      return [].concat(errorPath);\n    } : _c,\n        _d = _a.fragments,\n        fragments = _d === void 0 ? {} : _d;\n    this.path = path;\n    this.queryTransformer = queryTransformer;\n    this.resultTransformer = resultTransformer;\n    this.errorPathTransformer = errorPathTransformer;\n    this.fragments = fragments;\n  }\n\n  TransformQuery.prototype.transformRequest = function (originalRequest) {\n    var _a;\n\n    var _this = this;\n\n    var document = originalRequest.document;\n    var pathLength = this.path.length;\n    var index = 0;\n    var newDocument = visit(document, (_a = {}, _a[Kind.FIELD] = {\n      enter: function enter(node) {\n        if (index === pathLength || node.name.value !== _this.path[index]) {\n          return false;\n        }\n\n        index++;\n\n        if (index === pathLength) {\n          var selectionSet = _this.queryTransformer(node.selectionSet, _this.fragments);\n\n          return __assign(__assign({}, node), {\n            selectionSet: selectionSet\n          });\n        }\n      },\n      leave: function leave() {\n        index--;\n      }\n    }, _a));\n    return __assign(__assign({}, originalRequest), {\n      document: newDocument\n    });\n  };\n\n  TransformQuery.prototype.transformResult = function (originalResult) {\n    var data = this.transformData(originalResult.data);\n    var errors = originalResult.errors;\n    return {\n      data: data,\n      errors: errors != null ? this.transformErrors(errors) : undefined\n    };\n  };\n\n  TransformQuery.prototype.transformData = function (data) {\n    var leafIndex = this.path.length - 1;\n    var index = 0;\n    var newData = data;\n\n    if (newData) {\n      var next = this.path[index];\n\n      while (index < leafIndex) {\n        if (data[next]) {\n          newData = newData[next];\n        } else {\n          break;\n        }\n\n        index++;\n        next = this.path[index];\n      }\n\n      newData[next] = this.resultTransformer(newData[next]);\n    }\n\n    return newData;\n  };\n\n  TransformQuery.prototype.transformErrors = function (errors) {\n    var _this = this;\n\n    return errors.map(function (error) {\n      var path = error.path;\n      var match = true;\n      var index = 0;\n\n      while (index < _this.path.length) {\n        if (path[index] !== _this.path[index]) {\n          match = false;\n          break;\n        }\n\n        index++;\n      }\n\n      var newPath = match ? path.slice(0, index).concat(_this.errorPathTransformer(path.slice(index))) : path;\n      return new GraphQLError(error.message, error.nodes, error.source, error.positions, newPath, error.originalError, error.extensions);\n    });\n  };\n\n  return TransformQuery;\n}();\n\nvar MapFields =\n/** @class */\nfunction () {\n  function MapFields(fieldNodeTransformerMap) {\n    this.transformer = new TransformObjectFields(function (_typeName, _fieldName, field) {\n      return toConfig(field);\n    }, function (typeName, fieldName, fieldNode, fragments) {\n      var typeTransformers = fieldNodeTransformerMap[typeName];\n\n      if (typeTransformers == null) {\n        return fieldNode;\n      }\n\n      var fieldNodeTransformer = typeTransformers[fieldName];\n\n      if (fieldNodeTransformer == null) {\n        return fieldNode;\n      }\n\n      return fieldNodeTransformer(fieldNode, fragments);\n    });\n  }\n\n  MapFields.prototype.transformSchema = function (schema) {\n    return this.transformer.transformSchema(schema);\n  };\n\n  MapFields.prototype.transformRequest = function (request) {\n    return this.transformer.transformRequest(request);\n  };\n\n  return MapFields;\n}();\n\nvar ExtendSchema =\n/** @class */\nfunction () {\n  function ExtendSchema(_a) {\n    var typeDefs = _a.typeDefs,\n        _b = _a.resolvers,\n        resolvers = _b === void 0 ? {} : _b,\n        defaultFieldResolver = _a.defaultFieldResolver,\n        fieldNodeTransformerMap = _a.fieldNodeTransformerMap;\n    this.typeDefs = typeDefs;\n    this.resolvers = resolvers;\n    this.defaultFieldResolver = defaultFieldResolver != null ? defaultFieldResolver : defaultMergedResolver;\n    this.transformer = new MapFields(fieldNodeTransformerMap != null ? fieldNodeTransformerMap : {});\n  }\n\n  ExtendSchema.prototype.transformSchema = function (schema) {\n    this.transformer.transformSchema(schema);\n    return addResolversToSchema({\n      schema: this.typeDefs ? extendSchema$1(schema, parse(this.typeDefs)) : schema,\n      resolvers: this.resolvers != null ? this.resolvers : {},\n      defaultFieldResolver: this.defaultFieldResolver\n    });\n  };\n\n  ExtendSchema.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return ExtendSchema;\n}();\n\nfunction renameFieldNode(fieldNode, name) {\n  return __assign(__assign({}, fieldNode), {\n    alias: {\n      kind: Kind.NAME,\n      value: fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value\n    },\n    name: {\n      kind: Kind.NAME,\n      value: name\n    }\n  });\n}\n\nfunction preAliasFieldNode(fieldNode, str) {\n  return __assign(__assign({}, fieldNode), {\n    alias: {\n      kind: Kind.NAME,\n      value: \"\" + str + (fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value)\n    }\n  });\n}\n\nfunction wrapFieldNode(fieldNode, path) {\n  var newFieldNode = fieldNode;\n  path.forEach(function (fieldName) {\n    newFieldNode = {\n      kind: Kind.FIELD,\n      name: {\n        kind: Kind.NAME,\n        value: fieldName\n      },\n      selectionSet: {\n        kind: Kind.SELECTION_SET,\n        selections: [fieldNode]\n      }\n    };\n  });\n  return newFieldNode;\n}\n\nfunction collectFields$1(selectionSet, fragments, fields, visitedFragmentNames) {\n  if (fields === void 0) {\n    fields = [];\n  }\n\n  if (visitedFragmentNames === void 0) {\n    visitedFragmentNames = {};\n  }\n\n  if (selectionSet != null) {\n    selectionSet.selections.forEach(function (selection) {\n      switch (selection.kind) {\n        case Kind.FIELD:\n          fields.push(selection);\n          break;\n\n        case Kind.INLINE_FRAGMENT:\n          collectFields$1(selection.selectionSet, fragments, fields, visitedFragmentNames);\n          break;\n\n        case Kind.FRAGMENT_SPREAD:\n          {\n            var fragmentName = selection.name.value;\n\n            if (!visitedFragmentNames[fragmentName]) {\n              visitedFragmentNames[fragmentName] = true;\n              collectFields$1(fragments[fragmentName].selectionSet, fragments, fields, visitedFragmentNames);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n  return fields;\n}\n\nfunction hoistFieldNodes(_a) {\n  var fieldNode = _a.fieldNode,\n      fieldNames = _a.fieldNames,\n      _b = _a.path,\n      path = _b === void 0 ? [] : _b,\n      _c = _a.delimeter,\n      delimeter = _c === void 0 ? '__gqltf__' : _c,\n      fragments = _a.fragments;\n  var alias = fieldNode.alias != null ? fieldNode.alias.value : fieldNode.name.value;\n  var newFieldNodes = [];\n\n  if (path.length) {\n    var remainingPathSegments_1 = path.slice();\n    var initialPathSegment_1 = remainingPathSegments_1.shift();\n    collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {\n      if (possibleFieldNode.name.value === initialPathSegment_1) {\n        newFieldNodes = newFieldNodes.concat(hoistFieldNodes({\n          fieldNode: preAliasFieldNode(possibleFieldNode, \"\" + alias + delimeter),\n          fieldNames: fieldNames,\n          path: remainingPathSegments_1,\n          delimeter: delimeter,\n          fragments: fragments\n        }));\n      }\n    });\n  } else {\n    collectFields$1(fieldNode.selectionSet, fragments).forEach(function (possibleFieldNode) {\n      if (!fieldNames || fieldNames.includes(possibleFieldNode.name.value)) {\n        newFieldNodes.push(preAliasFieldNode(possibleFieldNode, \"\" + alias + delimeter));\n      }\n    });\n  }\n\n  return newFieldNodes;\n}\n\nfunction appendFields(typeMap, typeName, fields) {\n  var type = typeMap[typeName];\n\n  if (type != null) {\n    var typeConfig = toConfig(type);\n    var newFields_1 = toObjMap(typeConfig.fields);\n    Object.keys(fields).forEach(function (fieldName) {\n      newFields_1[fieldName] = fields[fieldName];\n    });\n    type = new GraphQLObjectType(__assign(__assign({}, typeConfig), {\n      fields: newFields_1\n    }));\n  } else {\n    type = new GraphQLObjectType({\n      name: typeName,\n      fields: fields\n    });\n  }\n\n  typeMap[typeName] = type;\n}\n\nfunction removeFields(typeMap, typeName, testFn) {\n  var type = typeMap[typeName];\n  var typeConfig = toConfig(type);\n  var originalFields = typeConfig.fields;\n  var newFields = {};\n  var removedFields = {};\n  Object.keys(originalFields).forEach(function (fieldName) {\n    if (testFn(fieldName, originalFields[fieldName])) {\n      removedFields[fieldName] = originalFields[fieldName];\n    } else {\n      newFields[fieldName] = originalFields[fieldName];\n    }\n  });\n  type = new GraphQLObjectType(__assign(__assign({}, typeConfig), {\n    fields: newFields\n  }));\n  typeMap[typeName] = type;\n  return removedFields;\n}\n\nfunction createMergedResolver(_a) {\n  var fromPath = _a.fromPath,\n      dehoist = _a.dehoist,\n      _b = _a.delimeter,\n      delimeter = _b === void 0 ? '__gqltf__' : _b;\n\n  var parentErrorResolver = function parentErrorResolver(parent, args, context, info) {\n    return parent instanceof Error ? parent : defaultMergedResolver(parent, args, context, info);\n  };\n\n  var unwrappingResolver = fromPath != null ? function (parent, args, context, info) {\n    return parentErrorResolver(unwrapResult(parent, info, fromPath), args, context, info);\n  } : parentErrorResolver;\n  var dehoistingResolver = dehoist ? function (parent, args, context, info) {\n    return unwrappingResolver(dehoistResult(parent, delimeter), args, context, info);\n  } : unwrappingResolver;\n\n  var noParentResolver = function noParentResolver(parent, args, context, info) {\n    return parent ? dehoistingResolver(parent, args, context, info) : {};\n  };\n\n  return noParentResolver;\n}\n\nvar WrapFields =\n/** @class */\nfunction () {\n  function WrapFields(outerTypeName, wrappingFieldNames, wrappingTypeNames, fieldNames) {\n    var _a, _b;\n\n    var _this = this;\n\n    this.outerTypeName = outerTypeName;\n    this.wrappingFieldNames = wrappingFieldNames;\n    this.wrappingTypeNames = wrappingTypeNames;\n    this.numWraps = wrappingFieldNames.length;\n    this.fieldNames = fieldNames;\n    var remainingWrappingFieldNames = this.wrappingFieldNames.slice();\n    var outerMostWrappingFieldName = remainingWrappingFieldNames.shift();\n    this.transformer = new MapFields((_a = {}, _a[outerTypeName] = (_b = {}, _b[outerMostWrappingFieldName] = function (fieldNode, fragments) {\n      return hoistFieldNodes({\n        fieldNode: fieldNode,\n        path: remainingWrappingFieldNames,\n        fieldNames: _this.fieldNames,\n        fragments: fragments\n      });\n    }, _b), _a));\n  }\n\n  WrapFields.prototype.transformSchema = function (schema) {\n    var _a, _b;\n\n    var _this = this;\n\n    var typeMap = schema.getTypeMap();\n    var targetFields = removeFields(typeMap, this.outerTypeName, !this.fieldNames ? function () {\n      return true;\n    } : function (fieldName) {\n      return _this.fieldNames.includes(fieldName);\n    });\n    var wrapIndex = this.numWraps - 1;\n    var innerMostWrappingTypeName = this.wrappingTypeNames[wrapIndex];\n    appendFields(typeMap, innerMostWrappingTypeName, targetFields);\n\n    for (wrapIndex--; wrapIndex > -1; wrapIndex--) {\n      appendFields(typeMap, this.wrappingTypeNames[wrapIndex], (_a = {}, _a[this.wrappingFieldNames[wrapIndex + 1]] = {\n        type: typeMap[this.wrappingTypeNames[wrapIndex + 1]],\n        resolve: defaultMergedResolver\n      }, _a));\n    }\n\n    appendFields(typeMap, this.outerTypeName, (_b = {}, _b[this.wrappingFieldNames[0]] = {\n      type: typeMap[this.wrappingTypeNames[0]],\n      resolve: createMergedResolver({\n        dehoist: true\n      })\n    }, _b));\n    healSchema(schema);\n    return this.transformer.transformSchema(schema);\n  };\n\n  WrapFields.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return WrapFields;\n}();\n\nvar WrapType =\n/** @class */\nfunction () {\n  function WrapType(outerTypeName, innerTypeName, fieldName) {\n    this.transformer = new WrapFields(outerTypeName, [fieldName], [innerTypeName], undefined);\n  }\n\n  WrapType.prototype.transformSchema = function (schema) {\n    return this.transformer.transformSchema(schema);\n  };\n\n  WrapType.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return WrapType;\n}();\n\nvar HoistField =\n/** @class */\nfunction () {\n  function HoistField(typeName, path, newFieldName) {\n    var _a, _b;\n\n    var _this = this;\n\n    this.typeName = typeName;\n    this.path = path;\n    this.newFieldName = newFieldName;\n    this.pathToField = this.path.slice();\n    this.oldFieldName = this.pathToField.pop();\n    this.transformer = new MapFields((_a = {}, _a[typeName] = (_b = {}, _b[newFieldName] = function (fieldNode) {\n      return wrapFieldNode(renameFieldNode(fieldNode, _this.oldFieldName), _this.pathToField);\n    }, _b), _a));\n  }\n\n  HoistField.prototype.transformSchema = function (schema) {\n    var _a;\n\n    var _this = this;\n\n    var typeMap = schema.getTypeMap();\n    var innerType = this.pathToField.reduce(function (acc, pathSegment) {\n      return getNullableType(acc.getFields()[pathSegment].type);\n    }, typeMap[this.typeName]);\n    var targetField = removeFields(typeMap, innerType.name, function (fieldName) {\n      return fieldName === _this.oldFieldName;\n    })[this.oldFieldName];\n    var targetType = targetField.type;\n    appendFields(typeMap, this.typeName, (_a = {}, _a[this.newFieldName] = {\n      type: targetType,\n      resolve: createMergedResolver({\n        fromPath: this.pathToField\n      })\n    }, _a));\n    healSchema(schema);\n    return this.transformer.transformSchema(schema);\n  };\n\n  HoistField.prototype.transformRequest = function (originalRequest) {\n    return this.transformer.transformRequest(originalRequest);\n  };\n\n  return HoistField;\n}();\n\nvar ReplaceFieldWithFragment =\n/** @class */\nfunction () {\n  function ReplaceFieldWithFragment(targetSchema, fragments) {\n    this.targetSchema = targetSchema;\n    this.mapping = {};\n\n    for (var _i = 0, fragments_1 = fragments; _i < fragments_1.length; _i++) {\n      var _a = fragments_1[_i],\n          field = _a.field,\n          fragment = _a.fragment;\n      var parsedFragment = parseFragmentToInlineFragment$1(fragment);\n      var actualTypeName = parsedFragment.typeCondition.name.value;\n\n      if (!(actualTypeName in this.mapping)) {\n        this.mapping[actualTypeName] = Object.create(null);\n      }\n\n      var typeMapping = this.mapping[actualTypeName];\n\n      if (!(field in typeMapping)) {\n        typeMapping[field] = [parsedFragment];\n      } else {\n        typeMapping[field].push(parsedFragment);\n      }\n    }\n  }\n\n  ReplaceFieldWithFragment.prototype.transformRequest = function (originalRequest) {\n    var document = replaceFieldsWithFragments$1(this.targetSchema, originalRequest.document, this.mapping);\n    return __assign(__assign({}, originalRequest), {\n      document: document\n    });\n  };\n\n  return ReplaceFieldWithFragment;\n}();\n\nfunction replaceFieldsWithFragments$1(targetSchema, document, mapping) {\n  var _a;\n\n  var typeInfo = new TypeInfo(targetSchema);\n  return visit(document, visitWithTypeInfo(typeInfo, (_a = {}, _a[Kind.SELECTION_SET] = function (node) {\n    var parentType = typeInfo.getParentType();\n\n    if (parentType != null) {\n      var parentTypeName_1 = parentType.name;\n      var selections_1 = node.selections;\n\n      if (parentTypeName_1 in mapping) {\n        node.selections.forEach(function (selection) {\n          if (selection.kind === Kind.FIELD) {\n            var name_1 = selection.name.value;\n            var fragments = mapping[parentTypeName_1][name_1];\n\n            if (fragments != null && fragments.length > 0) {\n              var fragment = concatInlineFragments(parentTypeName_1, fragments);\n              selections_1 = selections_1.concat(fragment);\n            }\n          }\n        });\n      }\n\n      if (selections_1 !== node.selections) {\n        return __assign(__assign({}, node), {\n          selections: selections_1\n        });\n      }\n    }\n  }, _a)));\n}\n\nfunction parseFragmentToInlineFragment$1(definitions) {\n  if (definitions.trim().startsWith('fragment')) {\n    var document_1 = parse(definitions);\n\n    for (var _i = 0, _a = document_1.definitions; _i < _a.length; _i++) {\n      var definition = _a[_i];\n\n      if (definition.kind === Kind.FRAGMENT_DEFINITION) {\n        return {\n          kind: Kind.INLINE_FRAGMENT,\n          typeCondition: definition.typeCondition,\n          selectionSet: definition.selectionSet\n        };\n      }\n    }\n  }\n\n  var query = parse(\"{\" + definitions + \"}\").definitions[0];\n\n  for (var _b = 0, _c = query.selectionSet.selections; _b < _c.length; _b++) {\n    var selection = _c[_b];\n\n    if (selection.kind === Kind.INLINE_FRAGMENT) {\n      return selection;\n    }\n  }\n\n  throw new Error('Could not parse fragment');\n}\n\nvar WrapQuery =\n/** @class */\nfunction () {\n  function WrapQuery(path, wrapper, extractor) {\n    this.path = path;\n    this.wrapper = wrapper;\n    this.extractor = extractor;\n  }\n\n  WrapQuery.prototype.transformRequest = function (originalRequest) {\n    var _a;\n\n    var _this = this;\n\n    var document = originalRequest.document;\n    var fieldPath = [];\n    var ourPath = JSON.stringify(this.path);\n    var newDocument = visit(document, (_a = {}, _a[Kind.FIELD] = {\n      enter: function enter(node) {\n        fieldPath.push(node.name.value);\n\n        if (ourPath === JSON.stringify(fieldPath)) {\n          var wrapResult = _this.wrapper(node.selectionSet); // Selection can be either a single selection or a selection set. If it's just one selection,\n          // let's wrap it in a selection set. Otherwise, keep it as is.\n\n\n          var selectionSet = wrapResult != null && wrapResult.kind === Kind.SELECTION_SET ? wrapResult : {\n            kind: Kind.SELECTION_SET,\n            selections: [wrapResult]\n          };\n          return __assign(__assign({}, node), {\n            selectionSet: selectionSet\n          });\n        }\n      },\n      leave: function leave() {\n        fieldPath.pop();\n      }\n    }, _a));\n    return __assign(__assign({}, originalRequest), {\n      document: newDocument\n    });\n  };\n\n  WrapQuery.prototype.transformResult = function (originalResult) {\n    var rootData = originalResult.data;\n\n    if (rootData != null) {\n      var data = rootData;\n\n      var path = __spreadArrays(this.path);\n\n      while (path.length > 1) {\n        var next = path.shift();\n\n        if (data[next]) {\n          data = data[next];\n        }\n      }\n\n      data[path[0]] = this.extractor(data[path[0]]);\n    }\n\n    return {\n      data: rootData,\n      errors: originalResult.errors\n    };\n  };\n\n  return WrapQuery;\n}();\n\nvar ExtractField =\n/** @class */\nfunction () {\n  function ExtractField(_a) {\n    var from = _a.from,\n        to = _a.to;\n    this.from = from;\n    this.to = to;\n  }\n\n  ExtractField.prototype.transformRequest = function (originalRequest) {\n    var _a, _b;\n\n    var fromSelection;\n    var ourPathFrom = JSON.stringify(this.from);\n    var ourPathTo = JSON.stringify(this.to);\n    var fieldPath = [];\n    visit(originalRequest.document, (_a = {}, _a[Kind.FIELD] = {\n      enter: function enter(node) {\n        fieldPath.push(node.name.value);\n\n        if (ourPathFrom === JSON.stringify(fieldPath)) {\n          fromSelection = node.selectionSet;\n          return BREAK;\n        }\n      },\n      leave: function leave() {\n        fieldPath.pop();\n      }\n    }, _a));\n    fieldPath = [];\n    var newDocument = visit(originalRequest.document, (_b = {}, _b[Kind.FIELD] = {\n      enter: function enter(node) {\n        fieldPath.push(node.name.value);\n\n        if (ourPathTo === JSON.stringify(fieldPath) && fromSelection != null) {\n          return __assign(__assign({}, node), {\n            selectionSet: fromSelection\n          });\n        }\n      },\n      leave: function leave() {\n        fieldPath.pop();\n      }\n    }, _b));\n    return __assign(__assign({}, originalRequest), {\n      document: newDocument\n    });\n  };\n\n  return ExtractField;\n}();\n\nfunction makeRemoteExecutableSchema(_a) {\n  var schemaOrTypeDefs = _a.schema,\n      link = _a.link,\n      fetcher = _a.fetcher,\n      _b = _a.createResolver,\n      createResolver = _b === void 0 ? defaultCreateRemoteResolver : _b,\n      _c = _a.createSubscriptionResolver,\n      createSubscriptionResolver = _c === void 0 ? defaultCreateRemoteSubscriptionResolver : _c,\n      buildSchemaOptions = _a.buildSchemaOptions;\n  var finalFetcher = fetcher;\n\n  if (finalFetcher == null && link != null) {\n    finalFetcher = linkToFetcher(link);\n  }\n\n  var targetSchema = typeof schemaOrTypeDefs === 'string' ? buildSchema(schemaOrTypeDefs, buildSchemaOptions) : schemaOrTypeDefs;\n  return wrapSchema({\n    schema: targetSchema,\n    createProxyingResolver: function createProxyingResolver(_schema, _transforms, operation) {\n      if (operation === 'query' || operation === 'mutation') {\n        return createResolver(finalFetcher);\n      }\n\n      return createSubscriptionResolver(link);\n    }\n  });\n}\n\nfunction defaultCreateRemoteResolver(fetcher) {\n  return function (_parent, _args, context, info) {\n    return _delegateToSchema({\n      schema: {\n        schema: info.schema,\n        fetcher: fetcher\n      },\n      context: context,\n      info: info\n    });\n  };\n}\n\nfunction defaultCreateRemoteSubscriptionResolver(link) {\n  return function (_parent, _args, context, info) {\n    return _delegateToSchema({\n      schema: {\n        schema: info.schema,\n        link: link\n      },\n      context: context,\n      info: info\n    });\n  };\n}\n\nexport { AddArgumentsAsVariables, AddMergedTypeFragments as AddMergedTypeSelectionSets, AddReplacementFragments, AddReplacementSelectionSets, AddTypenameToAbstract, AwaitVariablesLink, CheckResultAndHandleErrors, ExpandAbstractTypes, ExtendSchema, ExtractField, FilterInterfaceFields, FilterObjectFields, FilterRootFields, FilterToSchema, FilterTypes, GraphQLUpload, HoistField, MapFields, MapperKind, MockList, RenameInterfaceFields, RenameObjectFields, RenameRootFields, RenameRootTypes, RenameTypes, ReplaceFieldWithFragment, SchemaDirectiveVisitor, SchemaError, SchemaVisitor, TransformCompositeFields, TransformInterfaceFields, TransformObjectFields, TransformQuery, TransformRootFields, VisitSchemaKind, WrapFields, WrapQuery, WrapType, addCatchUndefinedToSchema, addErrorLoggingToSchema, addMockFunctionsToSchema, addMocksToSchema, addResolveFunctionsToSchema, addResolversToSchema, addSchemaLevelResolveFunction, addSchemaLevelResolver, argumentMapToConfig, argumentToConfig, assertResolveFunctionsPresent, assertResolversPresent, attachConnectorsToContext, attachDirectiveResolvers, buildSchema, buildSchemaFromTypeDefinitions, chainResolvers, checkForResolveTypeResolver, cloneDirective, cloneSchema, cloneType, concatenateTypeDefs, createRequest, createRequestFromInfo, createServerHttpLink, decorateWithLogger, defaultCreateProxyingResolver, defaultCreateRemoteResolver, defaultCreateRemoteSubscriptionResolver, defaultMergedResolver, delegateRequest, _delegateToSchema as delegateToSchema, directiveToConfig, enumTypeToConfig, extendResolversFromInterfaces, extendSchema, extractExtensionDefinitions, fieldMapToConfig, fieldToConfig, filterExtensionDefinitions, filterSchema, forEachDefaultValue, forEachField, getResolversFromSchema, graphqlVersion, healSchema, healTypes, inputFieldMapToConfig, inputFieldToConfig, inputObjectTypeToConfig, interfaceTypeToConfig, introspectSchema, isSpecifiedScalarType, isSubschemaConfig, makeExecutableSchema, makeRemoteExecutableSchema, mapSchema, mergeSchemas, mockServer, objectTypeToConfig, scalarTypeToConfig, schemaToConfig, toConfig, transformSchema, typeToConfig, unionTypeToConfig, visitSchema, wrapSchema };","map":null,"metadata":{},"sourceType":"module"}